#+TITLE: DotEmacs
#+AUTHOR: Mathieu Marques

* Table of Content                                                      :TOC:
- [[#bootstrap][Bootstrap]]
  - [[#core-packages][Core packages]]
  - [[#keybinds][Keybinds]]
  - [[#global-variables][Global variables]]
  - [[#use-better-defaults][Use better defaults]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
- [[#user-interface][User interface]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode-Line]]
  - [[#bars][Bars]]
  - [[#misc][Misc]]
- [[#languages][Languages]]
  - [[#css][CSS]]
  - [[#csv][CSV]]
  - [[#docker][Docker]]
  - [[#html][HTML]]
  - [[#javascript][JavaScript]]
  - [[#lisp][Lisp]]
  - [[#elisp][Elisp]]
  - [[#markdown][Markdown]]
  - [[#org][Org]]
  - [[#python][Python]]
  - [[#yaml][YAML]]
- [[#features][Features]]
  - [[#alert][Alert]]
  - [[#auto-completion][Auto-Completion]]
  - [[#buffers-and-windows][Buffers and Windows]]
  - [[#comments][Comments]]
  - [[#customization-menus][Customization Menus]]
  - [[#daemon][Daemon]]
  - [[#dictionary][Dictionary]]
  - [[#diff][Diff]]
  - [[#dired][Dired]]
  - [[#expand][Expand]]
  - [[#completion][Completion]]
  - [[#help][Help]]
  - [[#hydra][Hydra]]
  - [[#irc][IRC]]
  - [[#linters][Linters]]
  - [[#navigation][Navigation]]
  - [[#parentheses][Parentheses]]
  - [[#paste][Paste]]
  - [[#projectile][Projectile]]
  - [[#quality-of-life][Quality of Life]]
  - [[#shell-and-terminal][Shell and Terminal]]
  - [[#version-control][Version Control]]
  - [[#whitespaces][Whitespaces]]
- [[#symbols][Symbols]]
  - [[#symbols-1][Symbols]]
  - [[#fira-code][Fira Code]]

* Bootstrap

** Core packages

#+BEGIN_SRC emacs-lisp

(use-package async
    :defer t)

(use-package undo-tree
    :config
    (setq undo-tree-auto-save-history nil ; disable because unstable
        ;; undo-in-region is known to cause undo history corruption, which can
        ;; be very destructive! Disabling it deters the error, but does not fix
        ;; it entirely!
        undo-tree-enable-undo-in-region nil
        undo-tree-history-directory-alist
        `(("." . ,(concat my/cache-dir "undo-tree-hist/"))))
    (global-undo-tree-mode +1))

(add-to-list 'load-path "~/.emacs.d/util/")
(require 'core-util)
#+END_SRC



** Keybinds

#+BEGIN_SRC emacs-lisp

(use-package general)
(defalias 'define-key! #'general-def)
(defalias 'unmap! #'general-unbind)

#+END_SRC

** Global variables

Global variables that are used throughout the config

#+BEGIN_SRC emacs-lisp
(defvar my/emacs-dir
    (eval-when-compile (file-truename user-emacs-directory))
    "The path to the currently loaded .emacs.d directory. Must end with a slash.")

(defvar my/local-dir (concat my/emacs-dir ".local/")
  "Root directory for local storage.

Use this as a storage location for this system's installation of Doom Emacs.
These files should not be shared across systems. By default, it is used by
`doom-etc-dir' and `doom-cache-dir'. Must end with a slash.")

(defvar my/etc-dir (concat my/local-dir "etc/")
  "Directory for non-volatile local storage.

Use this for files that don't change much, like server binaries, external
dependencies or long-term shared data. Must end with a slash.")

(defvar my/cache-dir (concat my/local-dir "cache/")
  "Directory for volatile local storage.

Use this for files that change often, like cache files. Must end with a slash.")
#+END_SRC

** Use better defaults

Some UI elements are rather invasive. No-mouse master race.

#+BEGIN_SRC emacs-lisp
(when window-system
  (blink-cursor-mode -1)                           ; Disable the cursor blinking
  (scroll-bar-mode -1)                             ; Disable the scroll bar
  (tool-bar-mode -1)                               ; Disable the tool bar
  (tooltip-mode -1))                               ; Disable the tooltips
#+END_SRC

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp
(setq-default
    ad-redefinition-action 'accept                   ; Silence warnings for redefinition
    auto-window-vscroll nil                          ; Lighten vertical scroll
    cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
    delete-by-moving-to-trash t                      ; Delete files to trash
    display-time-default-load-average nil            ; Don't display load average
    display-time-format "%H:%M"                      ; Format the time string
    fill-column 80                                   ; Set width for automatic line breaks
    help-window-select t                             ; Focus new help windows when opened
    indent-tabs-mode nil                             ; Stop using tabs to indent
    inhibit-startup-screen t                         ; Disable start-up screen
    initial-scratch-message ""                       ; Empty the initial *scratch* buffer
    mouse-yank-at-point t                            ; Yank at point rather than pointer
    ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
    recenter-positions '(5 top bottom)               ; Set re-centering positions
    select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
    sentence-end-double-space nil                    ; End a sentence after a dot and a space
    show-trailing-whitespace nil                     ; Display trailing whitespaces
    split-height-threshold nil                       ; Disable vertical window splitting
    split-width-threshold nil                        ; Disable horizontal window splitting
    tab-width 4                                      ; Set width for tabs
    uniquify-buffer-name-style 'forward              ; Uniquify buffer names
    window-combination-resize t                      ; Resize windows proportionally
    x-stretch-cursor t                               ; Stretch cursor to the glyph width   
    ;; Scrolling
    hscroll-margin 2
    hscroll-step 1
    scroll-conservatively 1001
    scroll-margin 0
    scroll-preserve-screen-position t
    mouse-wheel-scroll-amount '(5 ((shift) . 2))
    mouse-wheel-progressive-speed nil ; don't accelerate scrolling
    ;; Dont litter .emacs.d/  
    abbrev-file-name             (concat my/local-dir "abbrev.el")
    async-byte-compile-log-file  (concat my/etc-dir "async-bytecomp.log")
    auto-save-list-file-name     (concat my/cache-dir "autosave")
    backup-directory-alist       (list (cons "." (concat my/cache-dir "backup/")))
    desktop-dirname              (concat my/etc-dir "desktop")
    desktop-base-file-name       "autosave"
    desktop-base-lock-name       "autosave-lock"
    pcache-directory             (concat my/cache-dir "pcache/")
    request-storage-directory    (concat my/cache-dir "request")
    server-auth-dir              (concat my/cache-dir "server/")
    shared-game-score-directory  (concat my/etc-dir "shared-game-score/")
    tramp-auto-save-directory    (concat my/cache-dir "tramp-auto-save/")
    tramp-backup-directory-alist backup-directory-alist
    tramp-persistency-file-name  (concat my/cache-dir "tramp-persistency.el")
    url-cache-directory          (concat my/cache-dir "url/")
    url-configuration-directory  (concat my/etc-dir "url/")
    gamegrid-user-score-file-directory (concat my/etc-dir "games/"))


                               
(cd "~/")                                         ; Move to the user directory
(delete-selection-mode 1)                         ; Replace region when inserting text
(display-time-mode 1)                             ; Enable time in the mode-line
(fringe-mode 0)                                   ; Disable fringes
(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
(global-subword-mode 1)                           ; Iterate through CamelCase words
(menu-bar-mode 0)                                 ; Disable the menu bar
(mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)              ; Enable downcase-region
(put 'upcase-region 'disabled nil)                ; Enable upcase-region
(set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
#+END_SRC

Enable fullscreen.

#+BEGIN_SRC emacs-lisp
(toggle-frame-maximized)
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs. It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself. By default, changes in the customization will be
automatically detected and appended at the end of the configuration file,
=init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up. The
following tells Emacs to add extra code in another file that would be then
loaded, if existing.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=. This is also where you want your API tokens to live.

#+BEGIN_SRC emacs-lisp
(defvar me/erc-nick               nil        "The ERC nick to use.")
(defvar me/erc-password           nil        "The ERC password to use.")
(defvar me/erc-port               nil        "The ERC port to use.")
(defvar me/erc-server             nil        "The ERC server to use.")
(defvar me/font-family            "Courier"  "The font to use.")
(defvar me/font-size-default      110        "The font size to use for default text.")
(defvar me/font-size-header-line  120        "The font size to use for the header-line.")
(defvar me/font-size-mode-line    110        "The font size to use for the mode-line.")
(defvar me/font-size-small        100        "The font size to use for smaller text.")
(defvar me/font-size-title        140        "The font size to use for titles.")

(let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
  (when (file-exists-p secret.el)
    (load secret.el)))
#+END_SRC

* User interface

** Theme

Load theme

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
    :demand t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-one t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

Loads solaire mode to dynamically darken/lighten focused windows

#+BEGIN_SRC emacs-lisp
(use-package solaire-mode
  :defer t
  :preface
  (defun solaire-mode-swap-bg-maybe ()
    (when-let (rule (assq doom-theme +doom-solaire-themes))
      (require 'solaire-mode)
      (when (cdr rule)
        (solaire-mode-swap-bg)
        (with-eval-after-load 'ansi-color
          (when-let (color (face-background 'default))
            (setf (aref ansi-color-names-vector 0) color))))))
  :hook
  ((change-major-mode after-revert ediff-prepare-buffer) . turn-on-solaire-mode)
  (minibuffer-setup . solaire-mode-in-minibuffer)
  (doom-load-theme . #'solaire-mode-swap-bg-maybe)
  (focus-in . #'solaire-mode-reset)
  :config
  (solaire-global-mode +1)
  (solaire-mode-swap-bg))
#+END_SRC

** Mode-Line

Mode line

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
    :ensure t
    :custom
    (find-file-visit-truename t)
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (projectile-dynamic-mode-line nil)
    (doom-modeline-bar-width 3)
    (doom-modeline-github nil)
    (doom-modeline-mu4e nil)
    (doom-modeline-persp-name nil)
    (doom-modeline-minor-modes nil)
    (doom-modeline-major-mode-icon nil)
    (doom-modeline-buffer-file-name-style 'relative-from-project)
    :hook (after-init . doom-modeline-mode))
#+END_SRC

Modeline for magit

#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line 
  :config      
  (defun +modeline|hide-in-non-status-buffer ()
"Show minimal modeline in magit-status buffer, no modeline elsewhere."
  (if (eq major-mode 'magit-status-mode)
      (doom-modeline-set-project-modeline)
      (hide-mode-line-mode))))
;; (add-hook 'magit-mode-hook #'+modeline|hide-in-non-status-buffer)
      ;; (magit-mode . #'+modeline|hide-in-non-status-buffer))
#+END_SRC

** Bars

*** Sidebar

For when you need to go explorin'

#+BEGIN_SRC emacs-lisp
(use-package treemacs
    :defer t
    :custom
    (treemacs-follow-after-init t)
    (treemacs-is-never-other-window t)
    (treemacs-sorting 'alphabetic-case-insensitive-desc)
    (treemacs-persist-file (concat my/cache-dir "treemacs-persist"))
    (treemacs-last-error-persist-file (concat my/cache-dir "treemacs-last-error-persist"))
    (doom-themes-treemacs-theme "doom-colors") ; Colorful theme 
    :config
    (treemacs-follow-mode -1)
    (with-eval-after-load 'treemacs-persistence
        (setq treemacs--last-error-persist-file 
            (concat my/cache-dir 
            "treemacs-persist-at-last-error")))
    (doom-themes-treemacs-config))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package treemacs-projectile
    :requires (treemacs projectile)
    :after (treemacs projectile)
    :defer t)

(use-package treemacs-magit
    :requires (treemacs evil)    
    :after (treemacs magit)
    :defer t)
#+END_SRC

*** Tabs


#+BEGIN_SRC emacs-lisp

(use-package centaur-tabs
    :bind
    (:map evil-normal-state-map
            ("g t" . centaur-tabs-forward)
            ("g T" . centaur-tabs-backward))
    :config
    ((setq centaur-tabs-set-icons t)
    (setq centaur-tabs-gray-out-icons 'buffer)
    (setq centaur-tabs-set-bar 'over)
    (setq centaur-tabs-set-modified-marker t))
    (centaur-tabs-mode +1))

#+END_SRC



** Misc

*** Linenumbers

#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode)
#+END_SRC


*** End of buffer

#+BEGIN_SRC emacs-lisp
(use-package vi-tilde-fringe
    :config
    (add-hook 'prog-mode-hook 'vi-tilde-fringe-mode))
#+END_SRC


* Languages

** CSS

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :ensure nil
  :custom (css-indent-offset 2))

(use-package scss-mode
  :ensure nil
  :preface
  (defun me/scss-set-comment-style ()
    (setq-local comment-end "")
    (setq-local comment-start "//"))
  :mode ("\\.sass\\'" "\\.scss\\'")
  :hook (scss-mode . me/scss-set-comment-style))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :config (setq-default csv-align-padding 2))
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode :mode "Dockerfile\\'")
#+END_SRC

** HTML

HTML mode is defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :ensure nil
  :preface
  (defun me/html-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((html-mode . me/html-set-pretty-print-function)
   (html-mode . sgml-electric-tag-pair-mode)
   (html-mode . sgml-name-8bit-mode)
   (html-mode . toggle-truncate-lines))
  :custom
  (sgml-basic-offset 2))
#+END_SRC

** JavaScript

- *TOFIX*: Indent level is broken
           (https://github.com/joshwnj/json-mode/issues/32).

#+BEGIN_SRC emacs-lisp
(use-package js
  :ensure nil
  :preface
  (defun me/js-prettify-symbols-mode-on ()
    (add-to-list 'prettify-symbols-alist '("function" . ?\u0192))
    (prettify-symbols-mode 1))
  :hook
  (js-mode . me/js-prettify-symbols-mode-on)
  :custom
  (js-indent-level 4))

(use-package js2-mode
  :ensure nil
  :custom
  (js2-idle-timer-delay 0)
  (js2-mode-show-parse-errors nil)
  (js2-mode-show-strict-warnings nil))

(use-package json-mode
  :mode "\\.json\\'"
  :preface
  (defun me/json-set-indent-level ()
    (setq-local js-indent-level 4))
  :hook (json-mode . me/json-set-indent-level))

(use-package rjsx-mode
  :preface
  (defun me/rjsx-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-rjsx/body))
  (defun me/rjsx-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((rjsx-mode . me/aggressive-indent-mode-off)
   (rjsx-mode . me/rjsx-set-ongoing-hydra-body)
   (rjsx-mode . me/rjsx-set-pretty-print-function)
   (rjsx-mode . sgml-electric-tag-pair-mode)
   (rjsx-mode . turn-off-auto-fill)))

(use-package typescript-mode
    :mode "\\.ts\\'")

;; (use-package tide
;;     :defer t
;;     :after typescript-mode
;;     :custom
;;     (tide-completion-detailed t)
;;     (tide-always-show-documentation t)
;;     :hook 
;;     (typescript-mode . tide))

(use-package web-mode
  :custom (web-mode-enable-auto-indentation nil))
#+END_SRC

** Lisp

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :ensure nil
  :hook (ielm-mode . (lambda () (setq-local scroll-margin 0))))
#+END_SRC

** Elisp

#+BEGIN_SRC
(add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)


#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :preface
  (defun me/markdown-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-markdown/body))
  :mode
  ("INSTALL\\'"
   "CONTRIBUTORS\\'"
   "LICENSE\\'"
   "README\\'"
   "\\.markdown\\'"
   "\\.md\\'")
  :hook
  (markdown-mode . me/markdown-set-ongoing-hydra-body)
  :custom
  (markdown-asymmetric-header t)
  (markdown-split-window-direction 'right)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map))
#+END_SRC

** Org

This very file is organized with =org-mode=. I am definitely not a power user of
Org, but I'm getting there. :-)

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :preface
  (defun me/org-src-buffer-name (org-buffer-name language)
    "Construct the buffer name for a source editing buffer. See
`org-src--construct-edit-buffer-name'."
    (format "*%s*" org-buffer-name))
  (defun me/org-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-org/body))
  :bind
  (:map org-mode-map
        ([remap backward-paragraph] . me/backward-paragraph-dwim)
        ([remap forward-paragraph] . me/forward-paragraph-dwim)
        ("<C-return>" . nil)
        ("<C-S-down>" . nil)
        ("<C-S-up>" . nil)
        ("<M-S-down>" . nil)
        ("<M-S-up>" . nil))
  :hook
  ((org-mode . me/org-set-ongoing-hydra-body)
   (org-mode . org-sticky-header-mode)
   (org-mode . toc-org-enable))
  :custom
  (org-descriptive-links nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-src-window-setup 'current-window)
  (org-startup-folded nil)
  (org-startup-truncated nil)
  (org-support-shift-select 'always)
  :config
  (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer-name)
  (doom-themes-org-config))
#+END_SRC

Display the current Org header in the header-line.

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :custom
  (org-sticky-header-full-path 'full)
  (org-sticky-header-outline-path-separator " / ")
  :config
  (setq-default
   org-sticky-header-header-line-format
   '(:eval (setq org-sticky-header-stickyline (concat " " (org-sticky-header--fetch-stickyline))))))
#+END_SRC

Tired of having to manually update your tables of contents? This package will
maintain a TOC at the first heading that has a =:TOC:= tag.

#+BEGIN_SRC emacs-lisp
(use-package toc-org :after org)
#+END_SRC

** Python

- *TODO*: Fix for =ipython= 5.1.0.

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure nil
  :hook (python-mode . turn-on-prettify-symbols-mode)
  :config
  (when (executable-find "ipython")
    (setq-default
     python-shell-interpreter "ipython"
     python-shell-interpreter-args "--colors=Linux --profile=default --simple-prompt"
     python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
     python-shell-prompt-regexp "In \\[[0-9]+\\]: "
     python-shell-completion-setup-code
     "from IPython.core.completerlib import module_completion"
     python-shell-completion-module-string-code
     "';'.join(module_completion('''%s'''))\n"
     python-shell-completion-string-code
     "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode :mode "\\.yml\\'")
#+END_SRC

* Features

** Alert

#+BEGIN_QUOTE
Alert is a Growl-workalike for Emacs which uses a common notification interface
and multiple, selectable "styles", whose use is fully customizable by the user.

[[https://github.com/jwiegley/alert][John Wiegley]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package alert
  :config
  (when (eq system-type 'darwin)
    (setq-default alert-default-style 'osx-notifier)))
#+END_SRC

** Auto-Completion

Auto-completion at point. Display a small pop-in containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package company
  :bind
  (:map company-active-map
        ("RET" . nil)
        ([return] . nil)
        ("TAB" . company-complete-selection)
        ([tab] . company-complete-selection)
        ("<right>" . company-complete-common))
  :hook
  (after-init . global-company-mode)
  :custom
  (company-dabbrev-downcase nil)
  (company-idle-delay .2)
  (company-minimum-prefix-length 1)
  (company-require-match nil)
  (company-tooltip-align-annotations t))
#+END_SRC

** Buffers and Windows

Don't ask before killing a buffer. I'm a consenting adult.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap kill-buffer] #'kill-this-buffer)
#+END_SRC

Allow repeated use of =←= and =→= when using =previous-buffer= and
=next-buffer=.

- *TODO*: Make a hydra.

#+BEGIN_SRC emacs-lisp
(defun me/switch-to-buffer-continue ()
  "Activate a sparse keymap:
  <left>   `previous-buffer'
  <right>  `next-buffer'"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<left>") #'previous-buffer)
     (define-key map (kbd "<right>") #'next-buffer)
     map)))
(advice-add 'previous-buffer :after #'me/switch-to-buffer-continue)
(advice-add 'next-buffer :after #'me/switch-to-buffer-continue)
#+END_SRC

Save and restore Emacs status, including buffers, point and window configurations.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :ensure nil
  :hook
  (after-init . desktop-read)
  (after-init . desktop-save-mode))
#+END_SRC

Workspaces within Emacs.

#+BEGIN_QUOTE
=eyebrowse= is a global minor mode for Emacs that allows you to manage your
window configurations in a simple manner, just like tiling window managers like
i3wm with their workspaces do. It displays their current state in the modeline
by default. The behaviour is modeled after
[[http://ranger.nongnu.org/][ranger]], a file manager written in Python.

[[https://github.com/wasamasa/eyebrowse][Vasilij Schneidermann]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :bind
  ("<f5>" . eyebrowse-switch-to-window-config-1)
  ("<f6>" . eyebrowse-switch-to-window-config-2)
  ("<f7>" . eyebrowse-switch-to-window-config-3)
  ("<f8>" . eyebrowse-switch-to-window-config-4)
  :hook
  (after-init . eyebrowse-mode)
  :custom
  (eyebrowse-new-workspace t))
#+END_SRC

Window management.

- *TODO*: Shackle Magit.

#+BEGIN_QUOTE
=shackle= gives you the means to put an end to popped up buffers not behaving they
way you'd like them to. By setting up simple rules you can for instance make
Emacs always select help buffers for you or make everything reuse your currently
selected window.

[[https://github.com/wasamasa/shackle][Vasilij Schneidermann]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :hook
  (after-init . shackle-mode)
  :custom
  (shackle-rules '((help-mode :inhibit-window-quit t :same t)))
  (shackle-select-reused-windows t))
#+END_SRC

Bind commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-M-<left>". windmove-left)
   ("C-M-<right>". windmove-right)
   ("C-M-<up>". windmove-up)
   ("C-M-<down>". windmove-down)))
#+END_SRC

Allow undo's and redo's with window configurations.

#+BEGIN_QUOTE
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the
changes can be "undone" using the command =winner-undo=.  By default this one is
bound to the key sequence ctrl-c left.  If you change your mind (while undoing),
you can press ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :hook (after-init . winner-mode))
#+END_SRC

** Comments

#+BEGIN_SRC emacs-lisp
(use-package newcomment
  :ensure nil
  :bind
  ("<M-return>" . comment-indent-new-line)
  :custom
  (comment-auto-fill-only-comments t)
  (comment-multi-line t))
#+END_SRC

** Customization Menus

This merely changes face attributes. It also /Zenburn/ customization buffers a
little more.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom (custom-unlispify-tag-names nil))
#+END_SRC

** Daemon

This package let us start a server to edit editable elements in a Chrome browser
from Emacs.

#+BEGIN_SRC emacs-lisp
(use-package edit-server
  :hook (after-init . edit-server-start))
#+END_SRC

Emacs can be run as a daemon onto which Emacs clients can latch on. This allows
for much shorter starting times when you already got Emacs running ie. when you
want to edit a single file for a quick edit.

#+BEGIN_SRC emacs-lisp
(use-package server
  :ensure nil
  :hook (after-init . server-start))
#+END_SRC

** Dictionary

Define words using Wordnik.

#+BEGIN_SRC emacs-lisp
(use-package define-word)
#+END_SRC

Translage using Google.

#+BEGIN_SRC emacs-lisp
(use-package google-translate)
#+END_SRC

** Diff

Ediff is a visual interface to Unix =diff=.

#+BEGIN_SRC emacs-lisp
(use-package ediff-wind
  :ensure nil
  :custom
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** Dired

Configure Dired buffers. Amongst many other things, Emacs is also a file
explorer.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :preface
  (defun me/dired-directories-first ()
    "Sort dired listings with directories first before adding marks."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2)
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))
  :hook
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-alh")
  (dired-ls-F-marks-symlinks nil)
  (dired-recursive-copies 'always)
  :config
  (advice-add 'dired-readin :after #'me/dired-directories-first))
#+END_SRC

** Expand

HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've
gathered all features that look anywhere close to this behavior for it to handle
under the same bind, that is =<C-return>=. Basically it's an expand DWIM.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil))
  :hook
  (css-mode html-mode rjsx-mode)
  :custom
  (emmet-insert-flash-time .1)
  (emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun me/emmet-try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args)))
  :bind
  ("<C-return>" . hippie-expand)
  :custom
  (hippie-expand-try-functions-list '(yas-hippie-try-expand me/emmet-try-expand-line))
  (hippie-expand-verbose nil))

(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
        ("TAB" . nil)
        ([tab] . nil))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (js-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (python-mode . yas-minor-mode)
   (csharp-mode . yas-minor-mode))
  :custom
  (yas-snippet-dirs `(,(expand-file-name "snippets/" my/emacs-dir)))
  (yas-verbosity 2)
  :config
  (yas-reload-all))
#+END_SRC

** Completion

*** Ivy


#+BEGIN_SRC emacs-lisp
(use-package ivy
    :defer t
    :init
    (setq ivy-re-builders-alist
        '((counsel-ag . ivy--regex-plus)
        (counsel-rg . ivy--regex-plus)
        (counsel-grep . ivy--regex-plus)
        (swiper . ivy--regex-plus)
        (swiper-isearch . ivy--regex-plus)
        ;; Ignore order for non-fuzzy searches by default
        (t . ivy--regex-ignore-order)))
    :config
    (setq ivy-height 15
        ivy-wrap t
        ivy-fixed-height-minibuffer t
        projectile-completion-system 'ivy
        ;; Don't use ^ as initial input
        ivy-initial-inputs-alist nil
        ;; highlight til EOL
        ivy-format-function #'ivy-format-function-line
        ;; disable magic slash on non-match
        ivy-magic-slash-non-match-action nil
        ;; don't show recent files in switch-buffer
        ivy-use-virtual-buffers nil
        ;; ...but if that ever changes, show their full path
        ivy-virtual-abbreviate 'full
        ;; don't quit minibuffer on delete-error
        ivy-on-del-error-function nil
        ;; enable ability to select prompt (alternative to `ivy-immediate-done')
        ivy-use-selectable-prompt t)

  ;; Ensure a jump point is registered before jumping to new locations with ivy
    (defvar +ivy--origin nil)

    (defun +ivy|record-position-maybe ()
        (with-ivy-window
        (setq +ivy--origin (point-marker))))
    (setq ivy-hooks-alist '((t . +ivy|record-position-maybe)))

    (defun +ivy|set-jump-point-maybe ()
        (when (and (markerp +ivy--origin)
                (not (equal (with-ivy-window (point-marker)) +ivy--origin)))
        (with-current-buffer (marker-buffer +ivy--origin)
            (better-jumper-set-jump +ivy--origin)))
        (setq +ivy--origin nil))
    (add-hook 'minibuffer-exit-hook #'+ivy|set-jump-point-maybe)

    (with-eval-after-load 'yasnippet
        (add-to-list 'yas-prompt-functions #'+ivy-yas-prompt nil #'eq))

    (defun +ivy*inhibit-ivy-in-evil-ex (orig-fn &rest args)
        "`ivy-completion-in-region' struggles with completing certain
    evil-ex-specific constructs, so we disable it solely in evil-ex."
        (let ((completion-in-region-function #'completion--in-region))
        (apply orig-fn args)))
    (advice-add #'evil-ex :around #'+ivy*inhibit-ivy-in-evil-ex)

    (define-key! ivy-mode-map
        [remap switch-to-buffer]              #'+ivy/switch-buffer
        [remap switch-to-buffer-other-window] #'+ivy/switch-buffer-other-window
        [remap persp-switch-to-buffer]        #'+ivy/switch-workspace-buffer)

    (define-key ivy-minibuffer-map (kbd "C-c C-e") #'+ivy/woccur)

    (ivy-mode +1)

    (use-package ivy-hydra
        :commands (ivy-dispatching-done-hydra ivy--matcher-desc ivy-hydra/body)
        :init
        (define-key! ivy-minibuffer-map
        "C-o" #'ivy-dispatching-done-hydra
        "M-o" #'hydra-ivy/body)
        :config
        ;; ivy-hydra rebinds this, so we have to do so again
        (define-key ivy-minibuffer-map (kbd "M-o") #'hydra-ivy/body)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package amx
    :config
    (setq amx-save-file (concat my/cache-dir "amx-items")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :commands counsel-describe-face
  :init
  (map! [remap apropos]                  #'counsel-apropos
        [remap bookmark-jump]            #'counsel-bookmark
        [remap describe-face]            #'counsel-faces
        [remap describe-function]        #'counsel-describe-function
        [remap describe-variable]        #'counsel-describe-variable
        [remap describe-bindings]        #'counsel-descbinds
        [remap set-variable]             #'counsel-set-variable
        [remap execute-extended-command] #'counsel-M-x
        [remap find-file]                #'counsel-find-file
        [remap find-library]             #'counsel-find-library
        [remap info-lookup-symbol]       #'counsel-info-lookup-symbol
        [remap imenu]                    #'counsel-imenu
        [remap recentf-open-files]       #'counsel-recentf
        [remap org-capture]              #'counsel-org-capture
        [remap swiper]                   #'counsel-grep-or-swiper
        [remap evil-ex-registers]        #'counsel-evil-registers
        [remap yank-pop]                 #'counsel-yank-pop)
  :config
;;   (set-popup-rule! "^\\*ivy-occur" :size 0.35 :ttl 0 :quit nil)

  (setq counsel-find-file-ignore-regexp "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)"
        counsel-describe-function-function #'helpful-callable
        counsel-describe-variable-function #'helpful-variable
        ;; Add smart-casing (-S) to default command arguments:
        counsel-rg-base-command "rg -S --no-heading --line-number --color never %s ."
        counsel-ag-base-command "ag -S --nocolor --nogroup %s"
        counsel-pt-base-command "pt -S --nocolor --nogroup -e %s")

  (add-to-list 'swiper-font-lock-exclude #'+doom-dashboard-mode nil #'eq)

  ;; Record in jumplist when opening files via counsel-{ag,rg,pt,git-grep}
  (add-hook 'counsel-grep-post-action-hook #'better-jumper-set-jump)

  ;; Factories
  (defun +ivy-action-reloading (cmd)
    (lambda (x)
      (funcall cmd x)
      (ivy--reset-state ivy-last)))

  (defun +ivy-action-given-file (cmd prompt)
    (lambda (source)
      (let* ((enable-recursive-minibuffers t)
             (target (read-file-name (format "%s %s to:" prompt source))))
        (funcall cmd source target 1))))

  ;; Configure `counsel-find-file'
  (ivy-add-actions
   'counsel-find-file
   `(("b" counsel-find-file-cd-bookmark-action "cd bookmark")
     ("s" counsel-find-file-as-root "open as root")
     ("m" counsel-find-file-mkdir-action "mkdir")
     ("c" ,(+ivy-action-given-file #'copy-file "Copy file") "copy file")
     ("d" ,(+ivy-action-reloading #'+ivy-confirm-delete-file) "delete")
     ("r" (lambda (path) (rename-file path (read-string "New name: "))) "rename")
     ("R" ,(+ivy-action-reloading (+ivy-action-given-file #'rename-file "Move")) "move")
     ("f" find-file-other-window "other window")
     ("F" find-file-other-frame "other frame")
     ("p" (lambda (path) (with-ivy-window (insert (file-relative-name path default-directory)))) "insert relative path")
     ("P" (lambda (path) (with-ivy-window (insert path))) "insert absolute path")
     ("l" (lambda (path) "Insert org-link with relative path"
            (with-ivy-window (insert (format "[[./%s]]" (file-relative-name path default-directory))))) "insert org-link (rel. path)")
     ("L" (lambda (path) "Insert org-link with absolute path"
            (with-ivy-window (insert (format "[[%s]]" path)))) "insert org-link (abs. path)")))

  (ivy-add-actions
   'counsel-ag ; also applies to `counsel-rg' & `counsel-pt'
   '(("O" +ivy-git-grep-other-window-action "open in other window"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :defer t
  :init
  (map! [remap projectile-find-file]        #'+ivy/projectile-find-file
        [remap projectile-find-dir]         #'counsel-projectile-find-dir
        [remap projectile-switch-to-buffer] #'counsel-projectile-switch-to-buffer
        [remap projectile-grep]             #'counsel-projectile-grep
        [remap projectile-ag]               #'counsel-projectile-ag
        [remap projectile-switch-project]   #'counsel-projectile-switch-project)
  :config
  ;; no highlighting visited files; slows down the filtering
  (ivy-set-display-transformer #'counsel-projectile-find-file nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package swiper)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-prescient
  :hook (ivy-mode . ivy-prescient-mode)
  :init
  (setq prescient-filter-method '(literal regexp initialism)
        ;; (if (featurep! +fuzzy)
        ;;     '(literal regexp initialism fuzzy)
        ;;   '(literal regexp initialism))
        ivy-prescient-enable-filtering t  ; we do this ourselves
        ivy-prescient-retain-classic-highlighting t
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist
        '((counsel-ag . +ivy-prescient-non-fuzzy)
          (counsel-rg . +ivy-prescient-non-fuzzy)
          (counsel-grep . +ivy-prescient-non-fuzzy)
          (swiper . +ivy-prescient-non-fuzzy)
          (swiper-isearch . +ivy-prescient-non-fuzzy)
          (t . ivy-prescient-re-builder)))

  :config
  (defun +ivy-prescient-non-fuzzy (str)
    (let ((prescient-filter-method '(literal regexp)))
      (ivy-prescient-re-builder str)))

  ;; NOTE prescient config duplicated with `company'
  (setq prescient-save-file (concat my/cache-dir "prescient-save.el"))
  (prescient-persist-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
    :after ivy
    :config  
    (cl-pushnew '(+ivy-rich-buffer-icon)
        (cadr (plist-get ivy-rich-display-transformers-list
                'ivy-switch-buffer)))

  ;; Include variable value in `counsel-describe-variable'
    (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                    'counsel-describe-variable
                    '(:columns
                        ((counsel-describe-variable-transformer (:width 40)) ; the original transformer
                        (+ivy-rich-describe-variable-transformer (:width 50))
                        (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))))

    ;; Remove built-in coloring of buffer list; we do our own
    (setq ivy-switch-buffer-faces-alist nil)
    (ivy-set-display-transformer 'internal-complete-buffer nil)

    ;; Highlight buffers differently based on whether they're in the same project
    ;; as the current project or not.
    (let* ((plist (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer))
            (switch-buffer-alist (assq 'ivy-rich-candidate (plist-get plist :columns))))
    (when switch-buffer-alist
        (setcar switch-buffer-alist '+ivy-rich-buffer-name)))

    ;; Apply switch buffer transformers to `counsel-projectile-switch-to-buffer' as well
    (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                    'counsel-projectile-switch-to-buffer
                    (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer)))

    ;; Reload ivy which so changes to `ivy-rich-display-transformers-list' work
    (ivy-rich-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :commands wgrep-change-to-wgrep-mode
  :config (setq wgrep-auto-save-buffer t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :after ivy
  :config
  ;; `all-the-icons-ivy' is incompatible with ivy-rich's switch-buffer
  ;; modifications, so we disable them and merge them ourselves
  (setq all-the-icons-ivy-buffer-commands nil)

  (all-the-icons-ivy-setup)
  (with-eval-after-load 'counsel-projectile
    (let ((all-the-icons-ivy-file-commands '(counsel-projectile
                                             counsel-projectile-find-file
                                             counsel-projectile-find-dir)))
      (all-the-icons-ivy-setup))))
#+END_SRC


*** Helm

;; Helm is a beast. Although heavily, it replaces =ido-mode= in many ways.

;; #+BEGIN_QUOTE
;; =Helm= is an Emacs framework for incremental completions and narrowing
;; selections. It helps to rapidly complete file names, buffer names, or any other
;; Emacs interactions requiring selecting an item from a list of possible choices.

;; Helm is a fork of =anything.el=, which was originally written by Tamas Patrovic
;; and can be considered to be its successor. =Helm= cleans the legacy code that is
;; leaner, modular, and unchained from constraints of backward compatibility.

;; [[https://github.com/emacs-helm/helm][Bozhidar Batsov]]
;; #+END_QUOTE


;; - *TODO*: Hide the buffer size column.
;; - *TODO*: Test =me/helm-pulse-follow= on MacOS. Is it Windows that makes it ugly?
;; - *TOFIX*: Help buffer resizes the frame.
;; - *TOFIX*: The recentering is too aggressive.
;; - *TOFIX*: Fix =me/helm-grab-candidates=.

;; #+BEGIN_SRC emacs-lisp
;; (use-package helm
;;   :preface
;;   (defun me/helm-focus-follow ()
;;     ;; (let ((point (point)))
;;     ;;   (when (and (pulse-available-p) (> point 1))
;;     ;;     (pulse-momentary-highlight-one-line point)))
;;     (recenter-top-bottom (car recenter-positions)))
;;   (defun me/helm-grab-candidates (beg end)
;;     (interactive "r")
;;     (if (region-active-p)
;;         (kill-ring-save beg end)
;;       (with-helm-buffer (kill-ring-save (point-min) (point-max)))))
;;   :bind
;;   (([remap execute-extended-command] . helm-M-x)
;;    ([remap find-file] . helm-find-files)
;;    ([remap isearch-forward] . helm-occur)
;;    ([remap switch-to-buffer] . helm-buffers-list)
;;    :map helm-map
;;    ("<left>" . backward-char)
;;    ("<right>" . forward-char)
;;    ("M-w" . me/helm-grab-candidates))
;;   :hook
;;   (after-init . helm-mode)
;;   (helm-after-action . me/helm-focus-follow)
;;   :custom
;;   (helm-M-x-fuzzy-match t)
;;   (helm-always-two-windows t)
;;   (helm-buffer-max-length nil)
;;   (helm-buffers-fuzzy-matching t)
;;   (helm-completion-in-region-fuzzy-match t)
;;   (helm-display-header-line nil)
;;   (helm-ff-no-preselect t)
;;   (helm-ff-skip-boring-files t)
;;   (helm-find-file-ignore-thing-at-point t)
;;   (helm-help-full-frame nil)
;;   (helm-mode-fuzzy-match t)
;;   (helm-net-prefer-curl (if (executable-find "curl") t nil))
;;   (helm-org-headings-fontify t)
;;   (helm-scroll-amount 5)
;;   (helm-split-window-default-side 'below)
;;   (helm-truncate-lines t))
;; #+END_SRC

;; #+BEGIN_SRC emacs-lisp
;; (use-package helm-imenu
;;   :ensure nil
;;   :bind
;;   (:map helm-imenu-map
;;         ("<left>" . backward-char)
;;         ("<right>" . forward-char)))
;; #+END_SRC

;; ** Helm Plugins

;; Fourth-party packages for Helm.

;; #+BEGIN_SRC emacs-lisp
;; (use-package helm-ag
;;   :bind
;;   (:map helm-ag-map
;;         ("<left>" . backward-char)
;;         ("<right>" . forward-char))
;;   :custom
;;   (helm-ag-show-status-function nil))

;; (use-package helm-descbinds
;;   :bind
;;   ([remap describe-bindings] . helm-descbinds)
;;   :custom
;;   (helm-descbinds-window-style 'split-window))

;; (use-package helm-describe-modes
;;   :bind ([remap describe-mode] . helm-describe-modes))

;; (use-package helm-projectile
;;   :defer nil
;;   :bind
;;   (:map helm-projectile-find-file-map
;;         ("<left>" . backward-char)
;;         ("<right>" . forward-char))
;;   :config
;;   (helm-projectile-toggle 1))
;; #+END_SRC

** Help

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Hydra

Hydra allows me to group binds together. It also shows a list of all implemented
commands in the echo area.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

[[https://github.com/abo-abo/hydra][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :bind
  ("C-c <tab>" . hydra-fold/body)
  ("C-c d" . hydra-dates/body)
  ("C-c e" . hydra-eyebrowse/body)
  ("C-c f" . hydra-flycheck/body)
  ("C-c g" . hydra-magit/body)
  ("C-c h" . hydra-helm/body)
  ("C-c o" . me/ongoing-hydra)
  ("C-c p" . hydra-projectile/body)
  ("C-c s" . hydra-system/body)
  ("C-c w" . hydra-windows/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

*** Hydra / Dates

Group date-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color blue)
  "
^
^Dates^             ^Insert^            ^Insert with Time^
^─────^─────────────^──────^────────────^────────────────^──
_q_ quit            _d_ short           _D_ short
^^                  _i_ iso             _I_ iso
^^                  _l_ long            _L_ long
^^                  ^^                  ^^
"
  ("q" nil)
  ("d" me/date-short)
  ("D" me/date-short-with-time)
  ("i" me/date-iso)
  ("I" me/date-iso-with-time)
  ("l" me/date-long)
  ("L" me/date-long-with-time))
#+END_SRC

[[./screenshots/hydra.dates.png]]

*** Hydra / Eyebrowse

Group Eyebrowse commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-eyebrowse (:color blue)
  "
^
^Eyebrowse^         ^Do^                ^Switch^
^─────────^─────────^──^────────────────^──────^────────────
_q_ quit            _c_ create          _<_ previous
^^                  _k_ kill            _>_ next
^^                  _r_ rename          _e_ last
^^                  ^^                  _s_ switch
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" eyebrowse-prev-window-config :color red)
  (">" eyebrowse-next-window-config :color red)
  ("c" eyebrowse-create-window-config)
  ("e" eyebrowse-last-window-config)
  ("k" eyebrowse-close-window-config :color red)
  ("r" eyebrowse-rename-window-config)
  ("s" eyebrowse-switch-to-window-config))
#+END_SRC

[[./screenshots/hydra.eyebrowse.png]]

*** Hydra / Flycheck

Group Flycheck commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck (:color pink)
  "
^
^Flycheck^          ^Errors^            ^Checker^
^────────^──────────^──────^────────────^───────^───────────
_q_ quit            _<_ previous        _?_ describe
_m_ manual          _>_ next            _d_ disable
_v_ verify setup    _f_ check           _s_ select
^^                  _l_ list            ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" flycheck-previous-error)
  (">" flycheck-next-error)
  ("?" flycheck-describe-checker :color blue)
  ("d" flycheck-disable-checker :color blue)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors :color blue)
  ("m" flycheck-manual :color blue)
  ("s" flycheck-select-checker :color blue)
  ("v" flycheck-verify-setup :color blue))
#+END_SRC

[[./screenshots/hydra.flycheck.png]]

*** Hydra / Helm

Group Helm commands.

- *TODO*: Make =helm-mdi=.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:color blue)
  "
^
^Helm^              ^Browse^
^────^──────────────^──────^────────────
_q_ quit            _c_ colors
_r_ resume          _g_ google
^^                  _i_ imenu
^^                  _k_ kill-ring
^^                  ^^
"
  ("q" nil)
  ("c" helm-colors)
  ("g" helm-google-suggest)
  ("i" helm-imenu)
  ("k" helm-show-kill-ring)
  ("r" helm-resume))
#+END_SRC

[[./screenshots/hydra.helm.png]]

*** Hydra / Magit

Group Magit commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-magit (:color blue)
  "
^
^Magit^             ^Do^
^─────^─────────────^──^────────────────
_q_ quit            _b_ blame
^^                  _c_ clone
^^                  _i_ init
^^                  _s_ status
^^                  ^^
"
  ("q" nil)
  ("b" magit-blame)
  ("c" magit-clone)
  ("i" magit-init)
  ("s" magit-status))
#+END_SRC

[[./screenshots/hydra.magit.png]]

*** Hydra / Markdown

Group Markdown commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-markdown (:color pink)
  "
^
^Markdown^          ^Table Columns^     ^Table Rows^
^────────^──────────^─────────────^─────^──────────^────────
_q_ quit            _c_ insert          _r_ insert
^^                  _C_ delete          _R_ delete
^^                  _M-<left>_ left     _M-<down>_ down
^^                  _M-<right>_ right   _M-<up>_ up
^^                  ^^                  ^^
"
  ("q" nil)
  ("c" markdown-table-insert-column)
  ("C" markdown-table-delete-column)
  ("r" markdown-table-insert-row)
  ("R" markdown-table-delete-row)
  ("M-<left>" markdown-table-move-column-left)
  ("M-<right>" markdown-table-move-column-right)
  ("M-<down>" markdown-table-move-row-down)
  ("M-<up>" markdown-table-move-row-up))
#+END_SRC

[[./screenshots/hydra.markdown.png]]

*** Hydra / Org

Group Org commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color pink)
  "
^
^Org^               ^Links^             ^Outline^
^───^───────────────^─────^─────────────^───────^───────────
_q_ quit            _i_ insert          _<_ previous
^^                  _n_ next            _>_ next
^^                  _p_ previous        _a_ all
^^                  _s_ store           _o_ goto
^^                  ^^                  _v_ overview
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" org-backward-element)
  (">" org-forward-element)
  ("a" outline-show-all)
  ("i" org-insert-link :color blue)
  ("n" org-next-link)
  ("o" helm-org-in-buffer-headings :color blue)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
#+END_SRC

[[./screenshots/hydra.org.png]]

*** Hydra / Projectile

Group Projectile commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-projectile (:color blue)
  "
^
^Projectile^        ^Buffers^           ^Find^              ^Search^
^──────────^────────^───────^───────────^────^──────────────^──────^────────────
_q_ quit            _b_ list            _d_ directory       _r_ replace
_i_ reset cache     _K_ kill all        _D_ root            _R_ regexp replace
^^                  _S_ save all        _f_ file            _s_ ag
^^                  ^^                  _p_ project         ^^
^^                  ^^                  ^^                  ^^
"
  ("q" nil)
  ("b" helm-projectile-switch-to-buffer)
  ("d" helm-projectile-find-dir)
  ("D" projectile-dired)
  ("f" helm-projectile-find-file)
  ("i" projectile-invalidate-cache :color red)
  ("K" projectile-kill-buffers)
  ("p" helm-projectile-switch-project)
  ("r" projectile-replace)
  ("R" projectile-replace-regexp)
  ("s" helm-projectile-ag)
  ("S" projectile-save-project-buffers))
#+END_SRC

[[./screenshots/hydra.projectile.png]]

*** Hydra / RJSX

Group React JavaScript commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-rjsx (:color pink)
  "
^
^RJSX^
^────^──────────────
_q_ quit
^^
"
  ("q" nil))
#+END_SRC

[[./screenshots/hydra.rjsx.png]]

*** Hydra / System

Group system-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-system (:color blue)
  "
^
^System^            ^Packages^          ^Processes^         ^Shell^
^──────^────────────^────────^──────────^─────────^─────────^─────^─────────────
_q_ quit            _p_ list            _s_ list            _e_ eshell
^^                  _P_ upgrade         ^^                  _t_ term
^^                  ^^                  ^^                  _T_ ansi-term
"
  ("q" nil)
  ("e" (eshell t))
  ("p" paradox-list-packages)
  ("P" paradox-upgrade-packages)
  ("s" list-processes)
  ("t" term)
  ("T" ansi-term))
#+END_SRC

[[./screenshots/hydra.system.png]]

*** Hydra / Windows

Group window-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-windows (:color pink)
  "
^
^Windows^           ^Window^            ^Zoom^
^───────^───────────^──────^────────────^────^──────────────
_q_ quit            _b_ balance         _-_ out
^^                  _i_ heighten        _+_ in
^^                  _j_ narrow          _=_ reset
^^                  _k_ lower           ^^
^^                  _l_ widen           ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("b" balance-windows)
  ("i" enlarge-window)
  ("j" shrink-window-horizontally)
  ("k" shrink-window)
  ("l" enlarge-window-horizontally)
  ("-" text-scale-decrease)
  ("+" text-scale-increase)
  ("=" (text-scale-increase 0)))
#+END_SRC

[[./screenshots/hydra.windows.png]]

** IRC

- *TODO*: Display the current count of users. =(hash-table-count erc-channel-users)=

#+BEGIN_SRC emacs-lisp
(use-package erc
  :ensure nil
  :preface
  (defun me/erc ()
    "Connect to `me/erc-server' on `me/erc-port' as `me/erc-nick' with
    `me/erc-password'."
    (interactive)
    (erc :server me/erc-server
         :port me/erc-port
         :nick me/erc-nick
         :password me/erc-password))
  (defun me/erc-bol-shifted ()
    "See `erc-bol'. Support shift."
    (interactive "^")
    (erc-bol))
  (defun me/erc-set-fill-column ()
    "Set `erc-fill-column' to the width of the current window."
    (save-excursion
      (walk-windows
       (lambda (window)
         (let ((buffer (window-buffer window)))
           (set-buffer buffer)
           (when (and (eq major-mode 'erc-mode) (erc-buffer-visible buffer))
             (setq erc-fill-column (- (window-width window) 2))))))))
;;   :bind
;;   (:map erc-mode-map
;;         ([remap erc-bol] . me/erc-bol-shifted)
;;         ("M-<down>" . erc-next-command)
;;         ("M-<up>" . erc-previous-command))
  :hook
  (erc-mode . (lambda () (setq-local scroll-margin 0)))
  (window-configuration-change . me/erc-set-fill-column)
  :custom
  (erc-autojoin-channels-alist '(("freenode.net" "#emacs")))
  (erc-fill-function 'erc-fill-static)
  (erc-fill-static-center 19)
  (erc-header-line-format nil)
  (erc-insert-timestamp-function 'erc-insert-timestamp-left)
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
  (erc-prompt (format "%18s" ">"))
  (erc-timestamp-format nil)
  :config
  (make-variable-buffer-local 'erc-fill-column)
  (erc-scrolltobottom-enable))
#+END_SRC

** Linters

Flycheck lints warnings and errors directly within buffers. It can check a lot
of different syntaxes, as long as you make sure that Emacs has access to the
binaries (see [[./README.org][README.org]]).

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook
  ((css-mode . flycheck-mode)
   (emacs-lisp-mode . flycheck-mode)
   (js-mode . flycheck-mode)
   (python-mode . flycheck-mode))
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay .3))
#+END_SRC

** Navigation

*** Navigation / Inline

Smarter =C-a=.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line] #'me/beginning-of-line-dwim)

(defun me/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
#+END_SRC

*** Navigation / Paragraphs

I disagree with Emacs' definition of paragraphs so I redefined the way it should
jump from one paragraph to another.

- *TOFIX*: Ignore invisible text.

#+BEGIN_SRC emacs-lisp
;; (global-set-key [remap backward-paragraph] #'me/backward-paragraph-dwim)
;; (global-set-key [remap forward-paragraph] #'me/forward-paragraph-dwim)

(defun me/backward-paragraph-dwim ()
  "Move backward to start of paragraph."
  (interactive "^")
  (skip-chars-backward "\n")
  (unless (search-backward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-min)))
  (skip-chars-forward "\n"))

(defun me/forward-paragraph-dwim ()
  "Move forward to start of next paragraph."
  (interactive "^")
  (skip-chars-forward "\n")
  (unless (search-forward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-max)))
  (skip-chars-forward "\n"))
#+END_SRC

*** Navigation / Pulse

Pulse temporarily highlights the background color of a line or region.

#+BEGIN_SRC emacs-lisp
(use-package pulse :ensure nil)
#+END_SRC

*** Navigation / Replace

Better search and replace features. Even though I prefer to use
=multiple-cursors= to replace text in different places at once, =anzu= has a
nice feedback on regexp matches.

#+BEGIN_QUOTE
=anzu.el= is an Emacs port of
[[https://github.com/osyo-manga/vim-anzu][anzu.vim]]. =anzu.el= provides a minor
mode which displays /current match/ and /total matches/ information in the
mode-line in various search modes.

[[https://github.com/syohex/emacs-anzu][Syohei Yoshida]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package anzu
    :bind
    ([remap query-replace] . anzu-query-replace-regexp)
    :hook
    (after-init . global-anzu-mode)
    :custom
    (anzu-cons-mode-line-p nil))
#+END_SRC

**** Evil
#+BEGIN_SRC emacs-lisp
(use-package evil-anzu
    :after (evil anzu))
#+END_SRC


*** Navigation / Scroll

Enable horizontal scroll.

- *TODO*: Scroll the window under cursor instead of where point is.

#+BEGIN_SRC emacs-lisp
(put 'scroll-left 'disabled nil)
(defun me/scroll-left ()
  (interactive)
  (when truncate-lines (scroll-left 2)))
(defun me/scroll-right ()
  (interactive)
  (when truncate-lines (scroll-right 2)))
(global-set-key (kbd "<wheel-left>") #'me/scroll-right)
(global-set-key (kbd "<wheel-right>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-down>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-up>") #'me/scroll-right)
#+END_SRC

Configure the mouse scroll.

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :ensure nil
  :custom
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(1 ((control) . 5))))
#+END_SRC

*** Navigation / Search

Isearch stands for /incremental search/. This means that search results are
highlighted while you are typing your query, incrementally. Since he who can do
more can do less, I've replaced default bindings with the regexp-equivalent
commands.

#+BEGIN_SRC emacs-lisp
(use-package isearch
    :defer t
    :ensure nil
    :bind
    (("C-S-r" . isearch-backward-regexp)
    ("C-S-s" . isearch-forward-regexp)
    :map isearch-mode-map
    ("<M-down>" . isearch-ring-advance)
    ("<M-up>" . isearch-ring-retreat)
    :map minibuffer-local-isearch-map
    ("<M-down>" . next-history-element)
    ("<M-up>" . previous-history-element))
    :init
    (setq-default
        isearch-allow-scroll t
        lazy-highlight-cleanup nil
        lazy-highlight-initial-delay 0))
#+END_SRC

** Parentheses

Highlight parenthese-like delimiters in a rainbow fashion. It ease the reading
when dealing with mismatched parentheses.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

I am still looking for the perfect parenthesis management setup as of
today... No package seem to please my person.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook
  (after-init . smartparens-global-mode)
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  :config
  (show-paren-mode 0)
  (require 'smartparens-config))
#+END_SRC

** Paste

#+BEGIN_QUOTE
This mode allows to paste whole buffers or parts of buffers to pastebin-like
services. It supports more than one service and will failover if one service
fails.

[[https://github.com/etu/webpaste.el][Elis Hirwing]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package webpaste
    :ensure t
    :defer t
    :config
    (setq webpaste-provider-priority '("gist.github.com" "ix.io" "dpaste.de"))
    (setq webpaste-paste-confirmation t))
#+END_SRC

** Projectile

Projectile brings project-level facilities to Emacs such as grep, find and
replace.

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook
  (after-init . projectile-global-mode)
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" my/cache-dir)
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory))
  :custom
  (projectile-completion-system 'helm)
  (projectile-enable-caching t))
#+END_SRC

** Quality of Life

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((css-mode . aggressive-indent-mode)
   (emacs-lisp-mode . aggressive-indent-mode)
   (js-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (sgml-mode . aggressive-indent-mode))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun me/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun me/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun me/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun me/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun me/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun me/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

Disable documentation for object at point in the echo area. It conflicts with Flycheck.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :config (global-eldoc-mode -1))
#+END_SRC

Add visual guides towards indenting levels.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook
  (python-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  :config
  (progn
        (defvar custom-buffer-hl-indent-mode nil)

        (defun me/disable-hl-indent ()
            (when highlight-indent-guides-mode
                (setq-local custom-buffer-hl-indent-mode t)
                (highlight-indent-guides-mode -1)))
        (add-hook 'evil-visual-state-entry-hook #'me/disable-hl-indent)

        (defun me/enable-hl-indent-maybe ()
            (when custom-buffer-hl-indent-mode
                (highlight-indent-guides-mode +1)))

        (add-hook 'evil-visual-state-exit-hook  #'me/enable-hl-indent-maybe)))
#+END_SRC

Highlight line under point.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
    :ensure nil
    :preface (defun me/hl-line-mode-off () (setq-local global-hl-line-mode nil))
    :hook (after-init . global-hl-line-mode)
    :config
    (progn
        (defvar custom-buffer-hl-line-mode nil)

        (defun me/disable-hl-line ()
            (when hl-line-mode
                (setq-local custom-buffer-hl-line-mode t)
                (hl-line-mode -1)))
        (add-hook 'evil-visual-state-entry-hook #'me/disable-hl-line)

        (defun me/enable-hl-line-maybe ()
            (when custom-buffer-hl-line-mode
                (hl-line-mode +1)))

        (add-hook 'evil-visual-state-exit-hook  #'me/enable-hl-line-maybe)))


#+END_SRC

Prettify symbols. Below is the configuration of the prettify-symbol feature. You
should enable the feature as a minor-mode and on a per-mode basis only.

#+BEGIN_SRC emacs-lisp
(use-package prog-mode
  :ensure nil
  :preface
  (defun me/prettify-symbols-compose-predicate (&rest arguments)
    (when (not (eq system-type 'windows-nt))
      (apply #'prettify-symbols-default-compose-p arguments)))
  :custom
  (prettify-symbols-compose-predicate #'me/prettify-symbols-compose-predicate)
  (prettify-symbols-unprettify-at-point 'right-edge))
#+END_SRC

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook prog-mode
  :custom (rainbow-x-colors-major-mode-list '()))
#+END_SRC

Turn on =auto-fill-mode= /almost/ everywhere.

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :hook
  ((prog-mode . turn-on-auto-fill)
   (text-mode . turn-on-auto-fill)))
#+END_SRC

** Shell and Terminal

#+BEGIN_SRC emacs-lisp
(use-package em-hist
  :ensure nil
  :custom (eshell-hist-ignoredups t))

(use-package esh-mode
  :ensure nil
  :preface
  (defun me/eshell-bol-shifted ()
    "See `eshell-bol'. Support shift."
    (interactive "^")
    (eshell-bol))
  :bind
  (:map eshell-mode-map
        ([remap eshell-bol] . me/eshell-bol-shifted))
  :hook
  ((eshell-mode . me/hl-line-mode-off)
   (eshell-mode . (lambda () (setq-local scroll-margin 0))))
  :custom
  (eshell-scroll-to-bottom-on-input t))
#+END_SRC

Yes, Emacs emulates terminals too.

#+BEGIN_SRC emacs-lisp
(use-package term
  :ensure nil
  :hook
  ((term-mode . me/hl-line-mode-off)
   (term-mode . (lambda () (setq-local scroll-margin 0)))))
#+END_SRC

Provide a way to invoke =bash= on Windows. This requires "Developer Mode" to
be enabled in the first place.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (defun me/bash ()
    (interactive)
    (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
      (shell))))
#+END_SRC

** Version Control

Magit provides Git facilities directly from within Emacs.

#+BEGIN_QUOTE
Magit is an interface to the version control system
[[https://git-scm.com/][Git]], implemented as an
[[https://www.gnu.org/software/emacs][Emacs]] package. Magit aspires to be a
complete Git porcelain. While we cannot (yet) claim that Magit wraps and
improves upon each and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version control tasks
directly from within Emacs. While many fine Git clients exist, only Magit and
Git itself deserve to be called porcelains.
[[https://magit.vc/about.html][(more)]]

[[https://github.com/magit/magit][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :preface
  (defun me/git-commit-auto-fill-everywhere ()
    (setq fill-column 72)
    (setq-local comment-auto-fill-only-comments nil))
  :hook
  (git-commit-mode . me/git-commit-auto-fill-everywhere)
  :custom
  (git-commit-summary-max-length 50))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  (:map magit-hunk-section-map
        ("RET" . magit-diff-visit-file-other-window)
        ([return] . magit-diff-visit-file-other-window))
  :custom
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-body nil)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside magit-diff-highlight-hunk-region-using-face))
  (magit-popup-display-buffer-action '((display-buffer-same-window)))
  (magit-refs-show-commit-count 'all)
  (magit-section-show-child-count t)
  :config
  (remove-hook 'magit-section-highlight-hook #'magit-section-highlight))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+END_SRC

** Whitespaces

Highlight space-like characters, eg. trailing spaces, tabs, empty lines.


#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure nil
  :hook
  ((prog-mode . whitespace-turn-on)
   (text-mode . whitespace-turn-on))
  :custom
  (whitespace-style '(face empty indentation::space tab trailing)))
#+END_SRC


Delete on save

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
    :config
    (setq ws-butler-global-exempt-modes
            (append ws-butler-global-exempt-modes
                    '(special-mode comint-mode term-mode eshell-mode)))
    (ws-butler-global-mode))
#+END_SRC



* Symbols

** Symbols

#+BEGIN_SRC emacs-lisp
(defvar +pretty-code-symbols
  '(;; org
    :name          "»"
    :src_block     "»"
    :src_block_end "«"
    ;; Functional
    :lambda        "λ"
    :def           "ƒ"
    :composition   "∘"
    :map           "↦"
    ;; Types
    :null          "∅"
    :true          "𝕋"
    :false         "𝔽"
    :int           "ℤ"
    :float         "ℝ"
    :str           "𝕊"
    :bool          "𝔹"
    ;; Flow
    :not           "￢"
    :in            "∈"
    :not-in        "∉"
    :and           "∧"
    :or            "∨"
    :for           "∀"
    :some          "∃"
    :return        "⟼"
    :yield         "⟻"
    ;; Other
    :tuple         "⨂"
    :pipe          "" ;; FIXME: find a non-private char
    :dot           "•")
  "Options plist for `set-pretty-symbols!'.

This should not contain any symbols from the Unicode Private Area! There is no
universal way of getting the correct symbol as that area varies from font to
font.")


(defvar +pretty-code-symbols-alist '((t))
  "An alist containing a mapping of major modes to its value for
`prettify-symbols-alist'.")

(defun +pretty-code--correct-symbol-bounds (ligature-alist)
  "Prepend non-breaking spaces to a ligature.

This way `compose-region' (called by `prettify-symbols-mode') will use the
correct width of the symbols instead of the width measured by `char-width'."
  (let ((len (length (car ligature-alist)))
        (acc (list   (cdr ligature-alist))))
    (while (> len 1)
      (setq acc (cons #X00a0 (cons '(Br . Bl) acc))
            len (1- len)))
    (cons (car ligature-alist) acc)))
(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))
  
(defun set-pretty-symbols! (modes &rest plist)
  "Associates string patterns with icons in certain major-modes.

  MODES is a major mode symbol or a list of them.
  PLIST is a property list whose keys must match keys in `+pretty-code-symbols',
and whose values are strings representing the text to be replaced with that
symbol. If the car of PLIST is nil, then unset any pretty symbols previously
defined for MODES.

The following properties are special:

  :alist ALIST
    Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
    `+pretty-code-symbols'.
  :merge BOOL
    If non-nil, merge with previously defined `prettify-symbols-alist',
    otherwise overwrite it.

For example, the rule for emacs-lisp-mode is very simple:

  (set-pretty-symbols! 'emacs-lisp-mode
    :lambda \"lambda\")

This will replace any instances of \"lambda\" in emacs-lisp-mode with the symbol
assicated with :lambda in `+pretty-code-symbols'.

Pretty symbols can be unset for emacs-lisp-mode with:

  (set-pretty-symbols! 'emacs-lisp-mode nil)"
  (declare (indent defun))
  (if (null (car-safe plist))
      (dolist (mode (doom-enlist modes))
        (delq (assq mode +pretty-code-symbols-alist)
              +pretty-code-symbols-alist))
    (let (results merge key)
      (while plist
        (pcase (setq key (pop plist))
          (:merge (setq merge (pop plist)))
          (:alist (setq results (append (pop plist) results)))
          (_
           (when-let (char (plist-get +pretty-code-symbols key))
             (push (cons (pop plist) char) results)))))
      (dolist (mode (doom-enlist modes))
        (unless merge
          (delq (assq mode +pretty-code-symbols-alist)
                +pretty-code-symbols-alist))
        (push (cons mode results) +pretty-code-symbols-alist)))))
(global-prettify-symbols-mode 1)

(defvar +pretty-code-enabled-modes t
    "List of major modes in which `prettify-symbols-mode' should be enabled.
If t, enable it everywhere. If the first element is 'not, enable it in any mode
besides what is listed.")

;; When you get to the right edge, it goes back to how it normally prints
(setq prettify-symbols-unprettify-at-point 'right-edge)

(defun +pretty-code|init-pretty-symbols ()
  "Enable `prettify-symbols-mode'.

If in fundamental-mode, or a mode derived from special, comint, eshell or term
modes, this function does nothing.

Otherwise it builds `prettify-code-symbols-alist' according to
`+pretty-code-symbols-alist' for the current major-mode."
  (unless (or (eq major-mode 'fundamental-mode)
              (eq (get major-mode 'mode-class) 'special)
              (derived-mode-p 'comint-mode 'eshell-mode 'term-mode))
    (when (or (eq +pretty-code-enabled-modes t)
              (if (eq (car +pretty-code-enabled-modes) 'not)
                  (not (memq major-mode (cdr +pretty-code-enabled-modes)))
                (memq major-mode +pretty-code-enabled-modes)))
      (setq prettify-symbols-alist
            (append (cdr (assq major-mode +pretty-code-symbols-alist))
                    (default-value 'prettify-symbols-alist)))
      (when prettify-symbols-mode
        (prettify-symbols-mode -1))
      (prettify-symbols-mode +1))))

(add-hook 'after-change-major-mode-hook #'+pretty-code|init-pretty-symbols)
#+END_SRC


** Fira Code

Fixing ligatures from fira code

#+BEGIN_SRC emacs-lisp
; Fira code
;; This works when using emacs --daemon + emacsclient
(add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
;; This works when using emacs without server/client
(set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
;; I haven't found one statement that makes both of the above situations work, so I use both for now

(defconst fira-code-font-lock-keywords-alist
  (mapcar (lambda (regex-char-pair)
            `(,(car regex-char-pair)
              (0 (prog1 ()
                   (compose-region (match-beginning 1)
                                   (match-end 1)
                                   ;; The first argument to concat is a string containing a literal tab
                                   ,(concat "   " (list (decode-char 'ucs (cadr regex-char-pair)))))))))
          '(("\\(www\\)"                   #Xe100)
            ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
            ("\\(\\*\\*\\*\\)"             #Xe102)
            ("\\(\\*\\*/\\)"               #Xe103)
            ("\\(\\*>\\)"                  #Xe104)
            ("[^*]\\(\\*/\\)"              #Xe105)
            ("\\(\\\\\\\\\\)"              #Xe106)
            ("\\(\\\\\\\\\\\\\\)"          #Xe107)
            ("\\({-\\)"                    #Xe108)
            ("\\(\\[\\]\\)"                #Xe109)
            ("\\(::\\)"                    #Xe10a)
            ("\\(:::\\)"                   #Xe10b)
            ("[^=]\\(:=\\)"                #Xe10c)
            ("\\(!!\\)"                    #Xe10d)
            ("\\(!=\\)"                    #Xe10e)
            ("\\(!==\\)"                   #Xe10f)
            ("\\(-}\\)"                    #Xe110)
            ("\\(--\\)"                    #Xe111)
            ("\\(---\\)"                   #Xe112)
            ("\\(-->\\)"                   #Xe113)
            ("[^-]\\(->\\)"                #Xe114)
            ("\\(->>\\)"                   #Xe115)
            ("\\(-<\\)"                    #Xe116)
            ("\\(-<<\\)"                   #Xe117)
            ("\\(-~\\)"                    #Xe118)
            ("\\(#{\\)"                    #Xe119)
            ("\\(#\\[\\)"                  #Xe11a)
            ("\\(##\\)"                    #Xe11b)
            ("\\(###\\)"                   #Xe11c)
            ("\\(####\\)"                  #Xe11d)
            ("\\(#(\\)"                    #Xe11e)
            ("\\(#\\?\\)"                  #Xe11f)
            ("\\(#_\\)"                    #Xe120)
            ("\\(#_(\\)"                   #Xe121)
            ("\\(\\.-\\)"                  #Xe122)
            ("\\(\\.=\\)"                  #Xe123)
            ("\\(\\.\\.\\)"                #Xe124)
            ("\\(\\.\\.<\\)"               #Xe125)
            ("\\(\\.\\.\\.\\)"             #Xe126)
            ("\\(\\?=\\)"                  #Xe127)
            ("\\(\\?\\?\\)"                #Xe128)
            ("\\(;;\\)"                    #Xe129)
            ("\\(/\\*\\)"                  #Xe12a)
            ("\\(/\\*\\*\\)"               #Xe12b)
            ("\\(/=\\)"                    #Xe12c)
            ("\\(/==\\)"                   #Xe12d)
            ("\\(/>\\)"                    #Xe12e)
            ("\\(//\\)"                    #Xe12f)
            ("\\(///\\)"                   #Xe130)
            ("\\(&&\\)"                    #Xe131)
            ("\\(||\\)"                    #Xe132)
            ("\\(||=\\)"                   #Xe133)
            ("[^|]\\(|=\\)"                #Xe134)
            ("\\(|>\\)"                    #Xe135)
            ("\\(\\^=\\)"                  #Xe136)
            ("\\(\\$>\\)"                  #Xe137)
            ("\\(\\+\\+\\)"                #Xe138)
            ("\\(\\+\\+\\+\\)"             #Xe139)
            ("\\(\\+>\\)"                  #Xe13a)
            ("\\(=:=\\)"                   #Xe13b)
            ("[^!/]\\(==\\)[^>]"           #Xe13c)
            ("\\(===\\)"                   #Xe13d)
            ("\\(==>\\)"                   #Xe13e)
            ("[^=]\\(=>\\)"                #Xe13f)
            ("\\(=>>\\)"                   #Xe140)
            ("\\(<=\\)"                    #Xe141)
            ("\\(=<<\\)"                   #Xe142)
            ("\\(=/=\\)"                   #Xe143)
            ("\\(>-\\)"                    #Xe144)
            ("\\(>=\\)"                    #Xe145)
            ("\\(>=>\\)"                   #Xe146)
            ("[^-=]\\(>>\\)"               #Xe147)
            ("\\(>>-\\)"                   #Xe148)
            ("\\(>>=\\)"                   #Xe149)
            ("\\(>>>\\)"                   #Xe14a)
            ("\\(<\\*\\)"                  #Xe14b)
            ("\\(<\\*>\\)"                 #Xe14c)
            ("\\(<|\\)"                    #Xe14d)
            ("\\(<|>\\)"                   #Xe14e)
            ("\\(<\\$\\)"                  #Xe14f)
            ("\\(<\\$>\\)"                 #Xe150)
            ("\\(<!--\\)"                  #Xe151)
            ("\\(<-\\)"                    #Xe152)
            ("\\(<--\\)"                   #Xe153)
            ("\\(<->\\)"                   #Xe154)
            ("\\(<\\+\\)"                  #Xe155)
            ("\\(<\\+>\\)"                 #Xe156)
            ("\\(<=\\)"                    #Xe157)
            ("\\(<==\\)"                   #Xe158)
            ("\\(<=>\\)"                   #Xe159)
            ("\\(<=<\\)"                   #Xe15a)
            ("\\(<>\\)"                    #Xe15b)
            ("[^-=]\\(<<\\)"               #Xe15c)
            ("\\(<<-\\)"                   #Xe15d)
            ("\\(<<=\\)"                   #Xe15e)
            ("\\(<<<\\)"                   #Xe15f)
            ("\\(<~\\)"                    #Xe160)
            ("\\(<~~\\)"                   #Xe161)
            ("\\(</\\)"                    #Xe162)
            ("\\(</>\\)"                   #Xe163)
            ("\\(~@\\)"                    #Xe164)
            ("\\(~-\\)"                    #Xe165)
            ("\\(~=\\)"                    #Xe166)
            ("\\(~>\\)"                    #Xe167)
            ("[^<]\\(~~\\)"                #Xe168)
            ("\\(~~>\\)"                   #Xe169)
            ("\\(%%\\)"                    #Xe16a)
            ("[0\[]\\(x\\)"                #Xe16b)
            ("[^:=]\\(:\\)[^:=]"           #Xe16c)
            ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
            ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

(defun add-fira-code-symbol-keywords ()
  (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

(add-hook 'prog-mode-hook
          #'add-fira-code-symbol-keywords)
#+END_SRC

-----

[[#dotemacs][Back to top]]

#+TITLE: DotEmacs
#+AUTHOR: Fredrik Larsson

* Table of Content                                                      :TOC:
- [[#bootstrap][Bootstrap]]
  - [[#constants][Constants]]
  - [[#use-better-defaults][Use better defaults]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
  - [[#core-packages][Core packages]]
  - [[#keybinds][Keybinds]]
- [[#evil][Evil]]
  - [[#general-evil][General Evil]]
- [[#user-interface][User interface]]
  - [[#theme][Theme]]
  - [[#mode-line][Mode-Line]]
  - [[#bars][Bars]]
  - [[#misc][Misc]]
- [[#languages][Languages]]
  - [[#css][CSS]]
  - [[#csv][CSV]]
  - [[#docker][Docker]]
  - [[#html][HTML]]
  - [[#javascript][JavaScript]]
  - [[#lisp][Lisp]]
  - [[#elisp][Elisp]]
  - [[#markdown][Markdown]]
  - [[#org][Org]]
  - [[#python][Python]]
  - [[#yaml][YAML]]
- [[#features][Features]]
  - [[#alert][Alert]]
  - [[#auto-completion][Auto-Completion]]
  - [[#buffers-and-windows][Buffers and Windows]]
  - [[#daemon][Daemon]]
  - [[#dictionary][Dictionary]]
  - [[#dired][Dired]]
  - [[#expand][Expand]]
  - [[#completion][Completion]]
  - [[#help][Help]]
  - [[#hydra][Hydra]]
  - [[#irc][IRC]]
  - [[#linters][Linters]]
  - [[#navigation][Navigation]]
  - [[#parentheses][Parentheses]]
  - [[#paste][Paste]]
  - [[#projectile][Projectile]]
  - [[#quality-of-life][Quality of Life]]
  - [[#shell-and-terminal][Shell and Terminal]]
  - [[#version-control][Version Control]]
  - [[#whitespaces][Whitespaces]]
- [[#symbols][Symbols]]
  - [[#symbols-1][Symbols]]

* Bootstrap

** Constants

#+BEGIN_SRC emacs-lisp
(defconst EMACS26+ (> emacs-major-version 25))
(defconst EMACS27+ (> emacs-major-version 26))

(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
(defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))
#+END_SRC

** Use better defaults

Enable fullscreen.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init 'toggle-frame-fullscreen)
#+END_SRC

Some UI elements are rather invasive. No-mouse master race.

#+BEGIN_SRC emacs-lisp

;; Prevent the glimpse of un-styled Emacs by setting these early.
(add-to-list 'default-frame-alist '(tool-bar-lines . 0))
(add-to-list 'default-frame-alist '(menu-bar-lines . 0))
(add-to-list 'default-frame-alist '(vertical-scroll-bars))
#+END_SRC

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp

(setq-default
    ad-redefinition-action 'accept                   ; Silence warnings for redefinition
    auto-window-vscroll nil                          ; Lighten vertical scroll
    cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
    delete-by-moving-to-trash t                      ; Delete files to trash
    display-time-default-load-average nil            ; Don't display load average
    display-time-format "%H:%M"                      ; Format the time string
    fill-column 80                                   ; Set width for automatic line breaks
    help-window-select t                             ; Focus new help windows when opened
    indent-tabs-mode nil                             ; Stop using tabs to indent
    inhibit-startup-screen t                         ; Disable start-up screen
    initial-scratch-message ""                       ; Empty the initial *scratch* buffer
    mouse-yank-at-point t                            ; Yank at point rather than pointer
    ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
    recenter-positions '(5 top bottom)               ; Set re-centering positions
    select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
    sentence-end-double-space nil                    ; End a sentence after a dot and a space
    show-trailing-whitespace nil                     ; Display trailing whitespaces
    split-height-threshold nil                       ; Disable vertical window splitting
    split-width-threshold nil                        ; Disable horizontal window splitting
    tab-width 4                                      ; Set width for tabs
    uniquify-buffer-name-style 'forward              ; Uniquify buffer names
    window-combination-resize t                      ; Resize windows proportionally
    x-stretch-cursor t                               ; Stretch cursor to the glyph width
    idle-update-delay 1                              ; update ui slightly less often
    ;; no beeping or blinking please
    ring-bell-function #'ignore
    visible-bell nil
    ;; Scrolling
    hscroll-margin 2
    hscroll-step 1
    scroll-conservatively 1001
    scroll-margin 0
    scroll-preserve-screen-position t
    mouse-wheel-scroll-amount '(5 ((shift) . 2))
    mouse-wheel-progressive-speed nil ; don't accelerate scrolling
    ;; be quiet at startup; don't load or display anything unnecessary
    inhibit-startup-message t
    inhibit-startup-echo-area-message user-login-name
    inhibit-default-init t
    initial-major-mode 'fundamental-mode
    initial-scratch-message nil
    ;; History & backup settings (save nothing, that's what git is for)
    ;; auto-save-default nil
    ;; create-lockfiles nil
    ;; history-length 500
    ;; make-backup-files nil  ; don't create backup~ files
    )


(cd "~/")                                         ; Move to the user directory
(delete-selection-mode 1)                         ; Replace region when inserting text
(display-time-mode 1)                             ; Enable time in the mode-line
(fringe-mode 0)                                   ; Disable fringes
(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
(global-subword-mode 1)                           ; Iterate through CamelCase words
(menu-bar-mode 0)                                 ; Disable the menu bar
(mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)              ; Enable downcase-region
(put 'upcase-region 'disabled nil)                ; Enable upcase-region
(blink-cursor-mode -1)                            ; Disable blinking cursor

(when (fboundp 'set-charset-priority)             ; UTF-8 as the default coding system
  (set-charset-priority 'unicode))     ; pretty
(prefer-coding-system 'utf-8)          ; pretty
(setq locale-coding-system 'utf-8)     ; please
(unless IS-WINDOWS
  (setq selection-coding-system 'utf-8))  ; with sugar on top
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs. It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself. By default, changes in the customization will be
automatically detected and appended at the end of the configuration file,
=init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up. The
following tells Emacs to add extra code in another file that would be then
loaded, if existing.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=. This is also where you want your API tokens to live.

#+BEGIN_SRC emacs-lisp
(defvar me/erc-nick               nil        "The ERC nick to use.")
(defvar me/erc-password           nil        "The ERC password to use.")
(defvar me/erc-port               nil        "The ERC port to use.")
(defvar me/erc-server             nil        "The ERC server to use.")
(defvar me/font-family            "Courier"  "The font to use.")
(defvar me/font-size-default      110        "The font size to use for default text.")
(defvar me/font-size-header-line  120        "The font size to use for the header-line.")
(defvar me/font-size-mode-line    110        "The font size to use for the mode-line.")
(defvar me/font-size-small        100        "The font size to use for smaller text.")
(defvar me/font-size-title        140        "The font size to use for titles.")

(let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
  (when (file-exists-p secret.el)
    (load secret.el)))
#+END_SRC

** Core packages

#+BEGIN_SRC emacs-lisp

(use-package async
    :defer t)

(use-package undo-tree
    :config
    (setq undo-tree-auto-save-history nil ; disable because unstable
        ;; undo-in-region is known to cause undo history corruption, which can
        ;; be very destructive! Disabling it deters the error, but does not fix
        ;; it entirely!
        undo-tree-enable-undo-in-region nil
        undo-tree-history-directory-alist
        `(("." . ,(concat my/cache-dir "undo-tree-hist/"))))
    (global-undo-tree-mode +1))

(add-to-list 'load-path "~/.emacs.d/util/")
(require 'core-util)
#+END_SRC


** Keybinds

#+BEGIN_SRC emacs-lisp

(use-package general)
(defalias 'define-key! #'general-def)
(defalias 'unmap! #'general-unbind)

#+END_SRC

* Evil

** General Evil

#+BEGIN_SRC emacs-lisp

(defun +evil--insert-newline (&optional above _noextranewline)
  (let ((pos (save-excursion (beginning-of-line-text) (point)))
        comment-auto-fill-only-comments)
    (require 'smartparens)
    (evil-narrow-to-field
      (if above
          (if (save-excursion (nth 4 (sp--syntax-ppss pos)))
              (evil-save-goal-column
                (setq evil-auto-indent nil)
                (goto-char pos)
                (let ((ws (abs (skip-chars-backward " \t"))))
                  ;; FIXME oh god why
                  (save-excursion
                    (if comment-line-break-function
                        (funcall comment-line-break-function)
                      (comment-indent-new-line))
                    (when (and (derived-mode-p 'c-mode 'c++-mode 'objc-mode 'java-mode 'js2-mode)
                               (eq (char-after) ?/))
                      (insert "*"))
                    (insert
                     (make-string (max 0 (+ ws (skip-chars-backward " \t")))
                                  32)))
                  (insert (make-string (max 1 ws) 32))))
            (evil-move-beginning-of-line)
            (insert (if use-hard-newlines hard-newline "\n"))
            (forward-line -1)
            (back-to-indentation))
        (evil-move-end-of-line)
        (cond ((sp-point-in-comment pos)
               (setq evil-auto-indent nil)
               (if comment-line-break-function
                   (funcall comment-line-break-function)
                 (comment-indent-new-line)))
              ;; TODO Find a better way to do this
              ((and (eq major-mode 'haskell-mode)
                    (fboundp 'haskell-indentation-newline-and-indent))
               (setq evil-auto-indent nil)
               (haskell-indentation-newline-and-indent))
              (t
               (insert (if use-hard-newlines hard-newline "\n"))
               (back-to-indentation)))))))

;;;###autoload
(defun +evil*insert-newline-below-and-respect-comments (orig-fn count)
  (if (or (not +evil-want-o/O-to-continue-comments)
          (not (eq this-command 'evil-open-below))
          (evil-insert-state-p))
      (funcall orig-fn count)
    (cl-letf (((symbol-function 'evil-insert-newline-below)
               (lambda () (+evil--insert-newline))))
      (let ((evil-auto-indent evil-auto-indent))
        (funcall orig-fn count)))))

;;;###autoload
(defun +evil*insert-newline-above-and-respect-comments (orig-fn count)
  (if (or (not +evil-want-o/O-to-continue-comments)
          (not (eq this-command 'evil-open-above))
          (evil-insert-state-p))
      (funcall orig-fn count)
    (cl-letf (((symbol-function 'evil-insert-newline-above)
               (lambda () (+evil--insert-newline 'above))))
      (let ((evil-auto-indent evil-auto-indent))
        (funcall orig-fn count)))))

;;;###autoload
(defun +evil*static-reindent (orig-fn &rest args)
  "Don't move cursor on indent."
  (save-excursion (apply orig-fn args)))

;;;###autoload
(defun +evil*resolve-vim-path (file-name)
  "Take a path and resolve any vim-like filename modifiers in it. This adds
support for most vim file modifiers, as well as:

  %:P   Resolves to `doom-project-root'.

See http://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers for
more information on modifiers."
  (let* (case-fold-search
         (regexp (concat "\\(?:^\\|[^\\\\]\\)"
                         "\\([#%]\\)"
                         "\\(\\(?::\\(?:[PphtreS~.]\\|g?s[^:\t\n ]+\\)\\)*\\)"))
         (matches
          (cl-loop with i = 0
                   while (and (< i (length file-name))
                              (string-match regexp file-name i))
                   do (setq i (1+ (match-beginning 0)))
                   and collect
                   (cl-loop for j to (/ (length (match-data)) 2)
                            collect (match-string j file-name)))))
    (dolist (match matches)
      (let ((flags (split-string (car (cdr (cdr match))) ":" t))
            (path (and buffer-file-name
                       (pcase (car (cdr match))
                         ("%" (file-relative-name buffer-file-name))
                         ("#" (save-excursion (other-window 1) (file-relative-name buffer-file-name))))))
            flag global)
        (if (not path)
            (setq path "")
          (while flags
            (setq flag (pop flags))
            (when (string-suffix-p "\\" flag)
              (setq flag (concat flag (pop flags))))
            (when (string-prefix-p "gs" flag)
              (setq global t
                    flag (substring flag 1)))
            (setq path
                  (or (pcase (substring flag 0 1)
                        ("p" (expand-file-name path))
                        ("~" (concat "~/" (file-relative-name path "~")))
                        ("." (file-relative-name path default-directory))
                        ("t" (file-name-nondirectory (directory-file-name path)))
                        ("r" (file-name-sans-extension path))
                        ("e" (file-name-extension path))
                        ("S" (shell-quote-argument path))
                        ("h"
                         (let ((parent (file-name-directory (expand-file-name path))))
                           (unless (equal (file-truename path)
                                          (file-truename parent))
                             (if (file-name-absolute-p path)
                                 (directory-file-name parent)
                               (file-relative-name parent)))))
                        ("s"
                         (if (featurep 'evil)
                             (when-let (args (evil-delimited-arguments (substring flag 1) 2))
                               (let ((pattern (evil-transform-vim-style-regexp (car args)))
                                     (replace (cadr args)))
                                 (replace-regexp-in-string
                                  (if global pattern (concat "\\(" pattern "\\).*\\'"))
                                  (evil-transform-vim-style-regexp replace) path t t
                                  (unless global 1))))
                           path))
                        ("P"
                         (let ((project-root (doom-project-root (file-name-directory (expand-file-name path)))))
                           (unless project-root
                             (user-error "Not in a project"))
                           (abbreviate-file-name project-root)))
                        (_ path))
                      "")))
          ;; strip trailing slash, if applicable
          (when (and (not (string= path "")) (equal (substring path -1) "/"))
            (setq path (substring path 0 -1))))
        (setq file-name
              (replace-regexp-in-string (format "\\(?:^\\|[^\\\\]\\)\\(%s\\)"
                                                (regexp-quote (string-trim-left (car match))))
                                        path file-name t t 1))))
    (replace-regexp-in-string regexp "\\1" file-name t)))

(with-eval-after-load 'evil (evil-define-command +evil*window-split (&optional count file)
  "Same as `evil-window-split', but focuses (and recenters) the new split."
  :repeat nil
  (interactive "P<f>")
  (split-window (selected-window) count
                (if evil-split-window-below 'above 'below))
  (call-interactively
   (if evil-split-window-below
       #'evil-window-up
     #'evil-window-down))
  (recenter)
  (when (and (not count) evil-auto-balance-windows)
    (balance-windows (window-parent)))
  (if file (evil-edit file))))

(with-eval-after-load 'evil (evil-define-command +evil*window-vsplit (&optional count file)
  "Same as `evil-window-vsplit', but focuses (and recenters) the new split."
  :repeat nil
  (interactive "P<f>")
  (split-window (selected-window) count
                (if evil-vsplit-window-right 'left 'right))
  (call-interactively
   (if evil-vsplit-window-right
       #'evil-window-left
     #'evil-window-right))
  (recenter)
  (when (and (not count) evil-auto-balance-windows)
    (balance-windows (window-parent)))
  (if file (evil-edit file))))

;;;###autoload
(defun +evil*escape (&rest _)
  "Call `doom/escape' if `evil-force-normal-state' is called interactively."
  (when (called-interactively-p 'any)
    (call-interactively #'doom/escape)))

;;;###autoload
(defun +evil*make-numbered-markers-global (orig-fn char)
  (or (and (>= char ?2) (<= char ?9))
      (funcall orig-fn char)))

;;;###autoload
(defun +evil*fix-dabbrev-in-minibuffer ()
  "Make `try-expand-dabbrev' from `hippie-expand' work in minibuffer. See
`he-dabbrev-beg', so we need to redefine syntax for '/'."
  (set-syntax-table (let* ((table (make-syntax-table)))
                      (modify-syntax-entry ?/ "." table)
                      table)))

(use-package evil
  :preface
  (setq evil-want-visual-char-semi-exclusive t
        evil-magic t
        evil-echo-state t
        evil-indent-convert-tabs t
        evil-ex-search-vim-style-regexp t
        evil-ex-substitute-global t
        evil-ex-visual-char-range t  ; column range for ex commands
        evil-insert-skip-empty-lines t
        evil-mode-line-format 'nil
        evil-respect-visual-line-mode t
        ;; more vim-like behavior
        evil-symbol-word-search t
        ;; cursor appearance
        evil-default-cursor '+evil-default-cursor
        evil-normal-state-cursor 'box
        evil-emacs-state-cursor  '(box +evil-emacs-cursor)
        evil-insert-state-cursor 'bar
        evil-visual-state-cursor 'hollow
        ;; must be set before evil/evil-collection is loaded
        evil-want-keybinding nil)

  :config
  (evil-select-search-module 'evil-search-module 'evil-search)

  (put 'evil-define-key* 'lisp-indent-function 'defun)

  ;; Start help-with-tutorial in emacs state
  (advice-add #'help-with-tutorial :after (lambda (&rest _) (evil-emacs-state +1)))

  ;; Change the cursor color in emacs state. We do it this roundabout way
  ;; instead of changing `evil-default-cursor' (or `evil-emacs-state-cursor') so
  ;; it won't interfere with users who have changed these variables.
  (defvar +evil--default-cursor-color "#ffffff")
  (defvar +evil--emacs-cursor-color "#ff9999")

  (defun +evil|update-cursor-color ()
    (setq +evil--default-cursor-color (face-background 'cursor)
          +evil--emacs-cursor-color (face-foreground 'warning)))
  (add-hook 'doom-load-theme-hook #'+evil|update-cursor-color)

  (defun +evil-default-cursor ()
    (evil-set-cursor-color +evil--default-cursor-color))
  (defun +evil-emacs-cursor ()
    (evil-set-cursor-color +evil--emacs-cursor-color))

  (defun +evil|update-shift-width ()
    (setq evil-shift-width tab-width))
  (add-hook 'after-change-major-mode-hook #'+evil|update-shift-width)


  ;; --- keybind fixes ----------------------
  (with-eval-after-load 'wgrep
    ;; A wrapper that invokes `wgrep-mark-deletion' across lines you use
    ;; `evil-delete' in wgrep buffers.
    (define-key wgrep-mode-map [remap evil-delete] #'+evil-delete))

  (defun +evil|disable-highlights ()
    "Disable ex search buffer highlights."
    (when (evil-ex-hl-active-p 'evil-ex-search)
      (evil-ex-nohighlight)
      t))
  (add-hook 'doom-escape-hook #'+evil|disable-highlights)


  ;; --- evil hacks -------------------------
  (defun +evil|display-vimlike-save-message ()
    "Shorter, vim-esque save messages."
    (message "\"%s\" %dL, %dC written"
             (if buffer-file-name
                 (file-relative-name (file-truename buffer-file-name) (projectile-project-root))
               (buffer-name))
             (count-lines (point-min) (point-max))
             (buffer-size)))
  (unless noninteractive
    (setq save-silently t)
    (add-hook 'after-save-hook #'+evil|display-vimlike-save-message))
  ;; Make ESC (from normal mode) the universal escaper. See `doom-escape-hook'.
  (advice-add #'evil-force-normal-state :after #'+evil*escape)
  ;; Don't move cursor when indenting
  (advice-add #'evil-indent :around #'+evil*static-reindent)
  ;; monkey patch `evil-ex-replace-special-filenames' to improve support for
  ;; file modifiers like %:p:h. This adds support for most of vim's modifiers,
  ;; and one custom one: %:P (expand to the project root).
  (advice-add #'evil-ex-replace-special-filenames :override #'+evil*resolve-vim-path)

  ;; make `try-expand-dabbrev' (from `hippie-expand') work in minibuffer
  (add-hook 'minibuffer-inactive-mode-hook #'+evil*fix-dabbrev-in-minibuffer)

  ;; Focus and recenter new splits
  (advice-add #'evil-window-split  :override #'+evil*window-split)
  (advice-add #'evil-window-vsplit :override #'+evil*window-vsplit)

  ;; In evil, registers 2-9 are buffer-local. In vim, they're global, so...
  (advice-add #'evil-global-marker-p :around #'+evil*make-numbered-markers-global)

  ;; Make o/O continue comments (see `+evil-want-o/O-to-continue-comments')
  (advice-add #'evil-open-above :around #'+evil*insert-newline-above-and-respect-comments)
  (advice-add #'evil-open-below :around #'+evil*insert-newline-below-and-respect-comments)

  ;; --- custom interactive codes -----------
  ;; These arg types will highlight matches in the current buffer
  (evil-ex-define-argument-type buffer-match :runner +evil-ex-buffer-match)
  (evil-ex-define-argument-type global-match :runner +evil-ex-global-match)
  ;; Other commands can make use of this
  (evil-define-interactive-code "<//>"
    :ex-arg buffer-match (list (if (evil-ex-p) evil-ex-argument)))
  (evil-define-interactive-code "<//g>"
    :ex-arg global-match (list (if (evil-ex-p) evil-ex-argument)))

  ;; By default :g[lobal] doesn't highlight matches in the current buffer. I've
  ;; got to write my own argument type and interactive code to get it to do so.
  (evil-ex-define-argument-type global-delim-match :runner +evil-ex-global-delim-match)
  (dolist (sym '(evil-ex-global evil-ex-global-inverted))
    (evil-set-command-property sym :ex-arg 'global-delim-match))

  ;; Forward declare these so that ex completion works, even if the autoloaded
  ;; functions aren't loaded yet.
  (evil-set-command-properties
   '+evil:align :move-point t :ex-arg 'buffer-match :ex-bang t :keep-visual t :suppress-operator t)
  (evil-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :config
  (evil-collection-init))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil-args
  :after evil)
#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-commentary
    :commands (evil-commentary
             evil-commentary-yank
             evil-commentary-yank-line
             evil-commentary-line)
  :config (evil-commentary-mode))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-easymotion
  :commands (evilem-create evilem-default-keybindings)
  :config
  ;; Use evil-search backend, instead of isearch
  (evilem-make-motion evilem-motion-search-next #'evil-ex-search-next
                      :bind ((evil-ex-search-highlight-all nil)))
  (evilem-make-motion evilem-motion-search-previous #'evil-ex-search-previous
                      :bind ((evil-ex-search-highlight-all nil)))

  (evilem-make-motion evilem-motion-search-word-forward #'evil-ex-search-word-forward
                      :bind ((evil-ex-search-highlight-all nil)))
  (evilem-make-motion evilem-motion-search-word-backward #'evil-ex-search-word-backward
                      :bind ((evil-ex-search-highlight-all nil))))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-embrace
  :commands (embrace-add-pair embrace-add-pair-regexp)
  :hook (LaTeX-mode . embrace-LaTeX-mode-hook)
  :hook (org-mode . embrace-org-mode-hook)
  :hook ((ruby-mode enh-ruby-mode) . embrace-ruby-mode-hook)
  :hook (emacs-lisp-mode . embrace-emacs-lisp-mode-hook)
  :hook ((lisp-mode emacs-lisp-mode clojure-mode racket-mode)
         . +evil|embrace-lisp-mode-hook)
  :hook ((org-mode LaTeX-mode) . +evil|embrace-latex-mode-hook)
  :hook ((c++-mode rust-mode rustic-mode csharp-mode java-mode swift-mode typescript-mode)
         . +evil|embrace-angle-bracket-modes-hook)
  :init
  (with-eval-after-load 'evil-surround
    (evil-embrace-enable-evil-surround-integration))
  :config
  (setq evil-embrace-show-help-p nil)

  (defun +evil|embrace-latex-mode-hook ()
    (embrace-add-pair-regexp ?l "\\[a-z]+{" "}" #'+evil--embrace-latex))

  (defun +evil|embrace-lisp-mode-hook ()
    (push (cons ?f (make-embrace-pair-struct
                    :key ?f
                    :read-function #'+evil--embrace-elisp-fn
                    :left-regexp "([^ ]+ "
                    :right-regexp ")"))
          embrace--pairs-list))

  (defun +evil|embrace-angle-bracket-modes-hook ()
    (set (make-local-variable 'evil-embrace-evil-surround-keys)
         (delq ?< evil-embrace-evil-surround-keys))
    (push (cons ?< (make-embrace-pair-struct
                    :key ?<
                    :read-function #'+evil--embrace-angle-brackets
                    :left-regexp "\\[a-z]+<"
                    :right-regexp ">"))
          embrace--pairs-list))

  ;; Add escaped-sequence support to embrace
  (setf (alist-get ?\\ (default-value 'embrace--pairs-list))
        (make-embrace-pair-struct
         :key ?\\
         :read-function #'+evil--embrace-escaped
         :left-regexp "\\[[{(]"
         :right-regexp "\\[]})]")))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-escape
    :after evil
    :commands (evil-escape)
    :init
    (setq evil-escape-excluded-states '(normal visual multiedit emacs motion)
            evil-escape-excluded-major-modes '(treemacs-mode vterm-mode)
            evil-escape-key-sequence "jk"
            evil-escape-delay 0.25)
    (evil-define-key* '(insert replace visual operator) 'global "\C-g" #'evil-escape)
  :config
  ;; no `evil-escape' in minibuffer
  (add-hook 'evil-escape-inhibit-functions #'minibufferp)
  ;; so that evil-escape-mode-hook runs, and can be toggled by evil-mc
  (evil-escape-mode +1))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-exchange
    :commands evil-exchange
    :config
    (defun +evil|escape-exchange ()
        (when evil-exchange--overlays
        (evil-exchange-cancel)
        t))
    (add-hook 'doom-escape-hook #'+evil|escape-exchange))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-indent-plus
  :after evil)

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-numbers
    :straight (:host github :repo "janpath/evil-numbers"))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-textobj-anyblock
  :after evil)

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-snipe
    :commands (evil-snipe-mode evil-snipe-override-mode
             evil-snipe-local-mode evil-snipe-override-local-mode)
  :init
  (setq evil-snipe-smart-case t
        evil-snipe-scope 'line
        evil-snipe-repeat-scope 'visible
        evil-snipe-char-fold t)
  :config
  (pushnew! evil-snipe-disabled-modes 'Info-mode 'calc-mode)
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-surround
    :commands (global-evil-surround-mode
             evil-surround-edit
             evil-Surround-edit
             evil-surround-region)
  :config (global-evil-surround-mode 1))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package evil-visualstar
    :after evil
    :commands
    (evil-visualstar/begin-search
        evil-visualstar/begin-search-forward
        evil-visualstar/begin-search-backward)
    :init
    (evil-define-key* 'visual 'global
        "*" #'evil-visualstar/begin-search-forward
        "#" #'evil-visualstar/begin-search-backward))

#+END_SRC

#+BEGIN_SRC emacs-lisp

(use-package exato
    :commands (evil-outer-xml-attr evil-inner-xml-attr))

#+END_SRC

*** ESCAPE

 Universal, non-nuclear escape

 `keyboard-quit' is too much of a nuclear option. I wanted an ESC/C-g to
 do-what-I-mean. It serves four purposes (in order):

 1. Quit active states e.g. highlights, searches, snippets, iedit,
    multiple-cursors, recording macros, etc.
 2. Close popup windows remotely (if it is allowed to)
 3. Refresh buffer indicators, like git-gutter and flycheck
 4. Or fall back to `keyboard-quit'

 And it should do these things incrementally, rather than all at once. And it
 shouldn't interfere with recording macros or the minibuffer. This may require
 you press ESC/C-g two or three times on some occasions to reach
 `keyboard-quit', but this is much more intuitive.
#+BEGIN_SRC emacs-lisp
(defvar doom-escape-hook nil
  "A hook run after C-g is pressed (or ESC in normal mode, for evil users). Both
trigger `doom/escape'.

If any hook returns non-nil, all hooks after it are ignored.")

(defun doom/escape ()
"Run `doom-escape-hook'."
  (interactive)
  (cond ((minibuffer-window-active-p (minibuffer-window))
         ;; quit the minibuffer if open.
         (abort-recursive-edit))
        ;; Run all escape hooks. If any returns non-nil, then stop there.
        ((run-hook-with-args-until-success 'doom-escape-hook))
        ;; don't abort macros
        ((or defining-kbd-macro executing-kbd-macro) nil)
        ;; Back to the default
        ((keyboard-quit))))

(global-set-key [remap keyboard-quit] #'doom/escape)
#+END_SRC 


*** Keybinds

    #+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-ex-define-cmd "ag"        #'+ivy:ag)
  (evil-ex-define-cmd "agc[wd]"   #'+ivy:ag-from-cwd)
  (evil-ex-define-cmd "rg"        #'+ivy:rg)
  (evil-ex-define-cmd "rgc[wd]"   #'+ivy:rg-from-cwd)
  (evil-ex-define-cmd "pt"        #'+ivy:pt)
  (evil-ex-define-cmd "ptc[wd]"   #'+ivy:pt-from-cwd)
  (evil-ex-define-cmd "grep"      #'+ivy:grep)
  (evil-ex-define-cmd "grepc[wd]" #'+ivy:grep-from-cwd)
  (evil-ex-define-cmd "sw[iper]"  #'+ivy:swipe)
  (evil-ex-define-cmd "todo"      #'+ivy:todo))
    #+END_SRC

* User interface

** Theme

   Load theme

   #+BEGIN_SRC emacs-lisp
(defvar load-theme-hook '())
(use-package doom-themes
    :demand t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-vibrant t))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
   #+END_SRC

   Loads solaire mode to dynamically darken/lighten focused windows

   #+BEGIN_SRC emacs-lisp
(use-package solaire-mode
  :defer t
  :preface
  (defun solaire-mode-swap-bg-maybe ()
    (when-let (rule (assq doom-theme +doom-solaire-themes))
      (require 'solaire-mode)
      (when (cdr rule)
        (solaire-mode-swap-bg)
        (with-eval-after-load 'ansi-color
          (when-let (color (face-background 'default))
            (setf (aref ansi-color-names-vector 0) color))))))
  :hook
  ((change-major-mode after-revert ediff-prepare-buffer) . turn-on-solaire-mode)
  (minibuffer-setup . solaire-mode-in-minibuffer)
  (doom-load-theme . #'solaire-mode-swap-bg-maybe)
  (focus-in . #'solaire-mode-reset)
  :config
  (solaire-global-mode +1)
  (solaire-mode-swap-bg))
   #+END_SRC

** Mode-Line

   Mode line

   #+BEGIN_SRC emacs-lisp
(use-package doom-modeline
    :custom
    (find-file-visit-truename t)
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (projectile-dynamic-mode-line t)
    (doom-modeline-bar-width 3)
    (doom-modeline-github nil)
    (doom-modeline-mu4e nil)
    (doom-modeline-persp-name nil)
    (doom-modeline-minor-modes nil)
    (doom-modeline-buffer-file-name-style 'relative-from-project)
    :hook
    (after-init . doom-modeline-mode)
    (theme-load . doom-modeline-mode)
    (org-mode . doom-modeline-mode)
    (theme-load . doom-modeline-refresh-bars)
    (doom-modeline-mode . size-indication-mode) ; filesize in modeline
    (doom-modeline-mode . column-number-mode)) ; cursor column in modeline
   #+END_SRC

   Modeline for magit

   #+BEGIN_SRC emacs-lisp
(use-package hide-mode-line
  :config
  (defun +modeline|hide-in-non-status-buffer ()
"Show minimal modeline in magit-status buffer, no modeline elsewhere."
  (if (eq major-mode 'magit-status-mode)
      (doom-modeline-set-project-modeline)
      (hide-mode-line-mode))))
;; (add-hook 'magit-mode-hook #'+modeline|hide-in-non-status-buffer)
      ;; (magit-mode . #'+modeline|hide-in-non-status-buffer))
   #+END_SRC

** Bars

*** Sidebar

    For when you need to go explorin'

    #+BEGIN_SRC emacs-lisp
(use-package treemacs
    :defer t
    :custom
    (treemacs-follow-after-init t)
    (treemacs-is-never-other-window t)
    (treemacs-sorting 'alphabetic-case-insensitive-desc)
    (treemacs-persist-file (concat my/cache-dir "treemacs-persist"))
    (treemacs-last-error-persist-file (concat my/cache-dir "treemacs-last-error-persist"))
    (doom-themes-treemacs-theme "doom-colors") ; Colorful theme
    :config
    (treemacs-follow-mode -1)
    (with-eval-after-load 'treemacs-persistence
        (setq treemacs--last-error-persist-file
            (concat my/cache-dir
            "treemacs-persist-at-last-error")))
    (doom-themes-treemacs-config))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package treemacs-projectile
    :requires (treemacs projectile)
    :after (treemacs projectile)
    :defer t)

(use-package treemacs-magit
    :requires (treemacs evil)
    :after (treemacs magit)
    :defer t)
    #+END_SRC

*** Tabs


    #+BEGIN_SRC emacs-lisp

(use-package centaur-tabs
    :config
    (setq centaur-tab-style "bar"
            centaur-tabs-height 32
            centaur-tabs-set-icons t
            ;; centaur-tabs-gray-out-icons 'buffer
            centaur-tabs-set-bar 'over
            centaur-tabs-set-modified-marker t)
    (centaur-tabs-group-by-projectile-project)
    (centaur-tabs-headline-match)
    :hook
    (prog-mode . centaur-tabs-local-mode)
    (dashboard-mode . centaur-tabs-local-mode)
    (term-mode . centaur-tabs-local-mode)
    (calendar-mode . centaur-tabs-local-mode)
    (org-agenda-mode . centaur-tabs-local-mode)
    (helpful-mode . centaur-tabs-local-mode)
    :config
    (centaur-tabs-mode t)
    :bind
    (:map evil-normal-state-map
            ("g t" . centaur-tabs-forward)
            ("g T" . centaur-tabs-backward)))

    #+END_SRC



** Misc

*** Linenumbers

    #+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'org-mode-hook 'display-line-numbers-mode)
(add-hook 'fundamental-mode-hook 'display-line-numbers-mode)
    #+END_SRC


*** End of buffer

    #+BEGIN_SRC emacs-lisp
(use-package vi-tilde-fringe
    :config
    (add-hook 'prog-mode-hook vi-tilde-fringe-mode)
    (add-hook 'text-mode-hook vi-tilde-fringe-mode)
    (add-hook 'fundamental-mode-hook vi-tilde-fringe-mode))
    #+END_SRC


* Languages

** CSS

   #+BEGIN_SRC emacs-lisp
(use-package css-mode
  :custom (css-indent-offset 2))

(use-package scss-mode
  :preface
  (defun me/scss-set-comment-style ()
    (setq-local comment-end "")
    (setq-local comment-start "//"))
  :mode ("\\.sass\\'" "\\.scss\\'")
  :hook (scss-mode . me/scss-set-comment-style))
   #+END_SRC

** CSV

   #+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :config (setq-default csv-align-padding 2))
   #+END_SRC

** Docker

   #+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode :mode "Dockerfile\\'")
   #+END_SRC

** HTML

   HTML mode is defined in =sgml-mode.el=.

   #+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :preface
  (defun me/html-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((html-mode . me/html-set-pretty-print-function)
   (html-mode . sgml-electric-tag-pair-mode)
   (html-mode . sgml-name-8bit-mode)
   (html-mode . toggle-truncate-lines))
  :custom
  (sgml-basic-offset 2))
   #+END_SRC

** JavaScript

   - *TOFIX*: Indent level is broken
     (https://github.com/joshwnj/json-mode/issues/32).

   #+BEGIN_SRC emacs-lisp
(use-package js
  :preface
  (defun me/js-prettify-symbols-mode-on ()
    (add-to-list 'prettify-symbols-alist '("function" . ?\u0192))
    (prettify-symbols-mode 1))
  :hook
  (js-mode . me/js-prettify-symbols-mode-on)
  :custom
  (js-indent-level 4))

(use-package js2-mode
  :custom
  (js2-idle-timer-delay 0)
  (js2-mode-show-parse-errors nil)
  (js2-mode-show-strict-warnings nil))

(use-package json-mode
  :mode "\\.json\\'"
  :preface
  (defun me/json-set-indent-level ()
    (setq-local js-indent-level 4))
  :hook (json-mode . me/json-set-indent-level))

(use-package rjsx-mode
  :preface
  (defun me/rjsx-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-rjsx/body))
  (defun me/rjsx-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((rjsx-mode . me/aggressive-indent-mode-off)
   (rjsx-mode . me/rjsx-set-ongoing-hydra-body)
   (rjsx-mode . me/rjsx-set-pretty-print-function)
   (rjsx-mode . sgml-electric-tag-pair-mode)
   (rjsx-mode . turn-off-auto-fill)))

(use-package typescript-mode
    :mode "\\.ts\\'")

;; (use-package tide
;;     :defer t
;;     :after typescript-mode
;;     :custom
;;     (tide-completion-detailed t)
;;     (tide-always-show-documentation t)
;;     :hook
;;     (typescript-mode . tide))

(use-package web-mode
  :custom (web-mode-enable-auto-indentation nil))
   #+END_SRC

** Lisp

   #+BEGIN_SRC emacs-lisp
(use-package ielm
  :hook (ielm-mode . (lambda () (setq-local scroll-margin 0))))
   #+END_SRC

** Elisp

   #+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)


   #+END_SRC

** Markdown

   #+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :preface
  (defun me/markdown-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-markdown/body))
  :mode
  ("INSTALL\\'"
   "CONTRIBUTORS\\'"
   "LICENSE\\'"
   "README\\'"
   "\\.markdown\\'"
   "\\.md\\'")
  :hook
  (markdown-mode . me/markdown-set-ongoing-hydra-body)
  :custom
  (markdown-asymmetric-header t)
  (markdown-split-window-direction 'right)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map))
   #+END_SRC

** Org

   This very file is organized with =org-mode=. I am definitely not a power user of
   Org, but I'm getting there. :-)

   #+BEGIN_QUOTE
   Org mode is for keeping notes, maintaining TODO lists, planning projects, and
   authoring documents with a fast and effective plain-text system.

   [[http://orgmode.org/][Carsten Dominik]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package org
  :preface
  (defun me/org-src-buffer-name (org-buffer-name language)
    "Construct the buffer name for a source editing buffer. See
`org-src--construct-edit-buffer-name'."
    (format "*%s*" org-buffer-name))
  (defun me/org-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-org/body))
  :bind
  (:map org-mode-map
        ([remap backward-paragraph] . me/backward-paragraph-dwim)
        ([remap forward-paragraph] . me/forward-paragraph-dwim)
        ("<C-return>" . nil)
        ("<C-S-down>" . nil)
        ("<C-S-up>" . nil)
        ("<M-S-down>" . nil)
        ("<M-S-up>" . nil))
  :hook
  ((org-mode . me/org-set-ongoing-hydra-body)
   (org-mode . org-sticky-header-mode)
   (org-mode . toc-org-enable))
  :custom
  (org-descriptive-links nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-src-window-setup 'current-window)
  (org-startup-folded nil)
  (org-startup-truncated nil)
  (org-support-shift-select 'always)
  :config
  (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer-name)
  (doom-themes-org-config))
   #+END_SRC

   Display the current Org header in the header-line.

   #+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :custom
  (org-sticky-header-full-path 'full)
  (org-sticky-header-outline-path-separator " / ")
  :config
  (setq-default
   org-sticky-header-header-line-format
   '(:eval (setq org-sticky-header-stickyline (concat " " (org-sticky-header--fetch-stickyline))))))
   #+END_SRC

   Tired of having to manually update your tables of contents? This package will
   maintain a TOC at the first heading that has a =:TOC:= tag.

   #+BEGIN_SRC emacs-lisp
(use-package toc-org :after org)
   #+END_SRC

** Python

   - *TODO*: Fix for =ipython= 5.1.0.

   #+BEGIN_SRC emacs-lisp
(use-package python
  :hook (python-mode . turn-on-prettify-symbols-mode)
  :config
  (when (executable-find "ipython")
    (setq-default
     python-shell-interpreter "ipython"
     python-shell-interpreter-args "--colors=Linux --profile=default --simple-prompt"
     python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
     python-shell-prompt-regexp "In \\[[0-9]+\\]: "
     python-shell-completion-setup-code
     "from IPython.core.completerlib import module_completion"
     python-shell-completion-module-string-code
     "';'.join(module_completion('''%s'''))\n"
     python-shell-completion-string-code
     "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")))
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
(use-package yaml-mode :mode "\\.yml\\'")
   #+END_SRC

* Features

** Alert

   #+BEGIN_QUOTE
   Alert is a Growl-workalike for Emacs which uses a common notification interface
   and multiple, selectable "styles", whose use is fully customizable by the user.

   [[https://github.com/jwiegley/alert][John Wiegley]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package alert
  :config
  (when (eq system-type 'darwin)
    (setq-default alert-default-style 'osx-notifier)))
   #+END_SRC

** Auto-Completion

   Auto-completion at point. Display a small pop-in containing the candidates.

   #+BEGIN_QUOTE
   Company is a text completion framework for Emacs. The name stands for "complete
   anything". It uses pluggable back-ends and front-ends to retrieve and display
   completion candidates.

   [[http://company-mode.github.io/][Dmitry Gutov]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package company
  :bind
  (:map company-active-map
        ("RET" . nil)
        ([return] . nil)
        ("TAB" . company-complete-selection)
        ([tab] . company-complete-selection)
        ("<right>" . company-complete-common))
  :hook
  (after-init . global-company-mode)
  :custom
  (company-dabbrev-downcase nil)
  (company-idle-delay .2)
  (company-minimum-prefix-length 1)
  (company-require-match nil)
  (company-tooltip-align-annotations t))
   #+END_SRC

** Buffers and Windows

   Don't ask before killing a buffer. I'm a consenting adult.

   #+BEGIN_SRC emacs-lisp
(global-set-key [remap kill-buffer] #'kill-this-buffer)
   #+END_SRC

   Allow repeated use of =←= and =→= when using =previous-buffer= and
   =next-buffer=.

   - *TODO*: Make a hydra.

   #+BEGIN_SRC emacs-lisp
(defun me/switch-to-buffer-continue ()
  "Activate a sparse keymap:
  <left>   `previous-buffer'
  <right>  `next-buffer'"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<left>") #'previous-buffer)
     (define-key map (kbd "<right>") #'next-buffer)
     map)))
(advice-add 'previous-buffer :after #'me/switch-to-buffer-continue)
(advice-add 'next-buffer :after #'me/switch-to-buffer-continue)
   #+END_SRC

   Save and restore Emacs status, including buffers, point and window configurations.

   #+BEGIN_SRC emacs-lisp
(use-package desktop
  :init
  (make-directory desktop-dirname :parents)
  :hook
  (after-init . desktop-read)
  (after-init . desktop-save-mode))
   #+END_SRC

   Workspaces within Emacs.

   #+BEGIN_QUOTE
   =eyebrowse= is a global minor mode for Emacs that allows you to manage your
   window configurations in a simple manner, just like tiling window managers like
   i3wm with their workspaces do. It displays their current state in the modeline
   by default. The behaviour is modeled after
   [[http://ranger.nongnu.org/][ranger]], a file manager written in Python.

   [[https://github.com/wasamasa/eyebrowse][Vasilij Schneidermann]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :bind
  ("<f5>" . eyebrowse-switch-to-window-config-1)
  ("<f6>" . eyebrowse-switch-to-window-config-2)
  ("<f7>" . eyebrowse-switch-to-window-config-3)
  ("<f8>" . eyebrowse-switch-to-window-config-4)
  :hook
  (after-init . eyebrowse-mode)
  :custom
  (eyebrowse-new-workspace t))
   #+END_SRC

   Window management.

   - *TODO*: Shackle Magit.

   #+BEGIN_QUOTE
   =shackle= gives you the means to put an end to popped up buffers not behaving they
   way you'd like them to. By setting up simple rules you can for instance make
   Emacs always select help buffers for you or make everything reuse your currently
   selected window.

   [[https://github.com/wasamasa/shackle][Vasilij Schneidermann]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package shackle
  :hook
  (after-init . shackle-mode)
  :custom
  (shackle-rules '((help-mode :inhibit-window-quit t :same t)))
  (shackle-select-reused-windows t))
   #+END_SRC

   Bind commands to move around windows.

   #+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("C-M-<left>". windmove-left)
   ("C-M-<right>". windmove-right)
   ("C-M-<up>". windmove-up)
   ("C-M-<down>". windmove-down)))
   #+END_SRC

   Allow undo's and redo's with window configurations.

   #+BEGIN_QUOTE
   Winner mode is a global minor mode that records the changes in the window
   configuration (i.e. how the frames are partitioned into windows) so that the
   changes can be "undone" using the command =winner-undo=.  By default this one is
   bound to the key sequence ctrl-c left.  If you change your mind (while undoing),
   you can press ctrl-c right (calling =winner-redo=).

   [[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package winner
  :hook (after-init . winner-mode))
   #+END_SRC

** Daemon

   This package let us start a server to edit editable elements in a Chrome browser
   from Emacs.

   #+BEGIN_SRC emacs-lisp
(use-package edit-server
  :hook (after-init . edit-server-start))
   #+END_SRC

   Emacs can be run as a daemon onto which Emacs clients can latch on. This allows
   for much shorter starting times when you already got Emacs running ie. when you
   want to edit a single file for a quick edit.

   #+BEGIN_SRC emacs-lisp
(use-package server
  :hook (after-init . server-start))
   #+END_SRC

** Dictionary

   Define words using Wordnik.

   #+BEGIN_SRC emacs-lisp
(use-package define-word)
   #+END_SRC

   Translage using Google.

   #+BEGIN_SRC emacs-lisp
(use-package google-translate)
   #+END_SRC

** Dired

   Configure Dired buffers. Amongst many other things, Emacs is also a file
   explorer.

   #+BEGIN_SRC emacs-lisp
(use-package dired
  :straight (dired :type built-in)
  :preface
  (defun me/dired-directories-first ()
    "Sort dired listings with directories first before adding marks."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2)
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))
  :hook
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-alh")
  (dired-ls-F-marks-symlinks nil)
  (dired-recursive-copies 'always)
  :config
  (advice-add 'dired-readin :after #'me/dired-directories-first))
   #+END_SRC

** Expand

   HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've
   gathered all features that look anywhere close to this behavior for it to handle
   under the same bind, that is =<C-return>=. Basically it's an expand DWIM.

   #+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil))
  :hook
  (css-mode html-mode rjsx-mode)
  :custom
  (emmet-insert-flash-time .1)
  (emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :preface
  (defun me/emmet-try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args)))
  :bind
  ("<C-return>" . hippie-expand)
  :custom
  (hippie-expand-try-functions-list '(yas-hippie-try-expand me/emmet-try-expand-line))
  (hippie-expand-verbose nil))

(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
        ("TAB" . nil)
        ([tab] . nil))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (js-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (python-mode . yas-minor-mode)
   (csharp-mode . yas-minor-mode))
  :custom
  (yas-snippet-dirs `(,(expand-file-name "snippets/" my/emacs-dir)))
  (yas-verbosity 2)
  :config
  (yas-reload-all))

(use-package yasnippet-snippets)

   #+END_SRC

** Completion

*** Ivy


    #+BEGIN_SRC emacs-lisp
(use-package ivy
    :defer t
    :init
    (setq ivy-re-builders-alist
        '((counsel-ag . ivy--regex-plus)
        (counsel-rg . ivy--regex-plus)
        (counsel-grep . ivy--regex-plus)
        (swiper . ivy--regex-plus)
        (swiper-isearch . ivy--regex-plus)
        ;; Ignore order for non-fuzzy searches by default
        (t . ivy--regex-ignore-order)))
    :config
    (setq ivy-height 15
        ivy-wrap t
        ivy-fixed-height-minibuffer t
        projectile-completion-system 'ivy
        ;; Don't use ^ as initial input
        ivy-initial-inputs-alist nil
        ;; highlight til EOL
        ivy-format-function #'ivy-format-function-line
        ;; disable magic slash on non-match
        ivy-magic-slash-non-match-action nil
        ;; don't show recent files in switch-buffer
        ivy-use-virtual-buffers nil
        ;; ...but if that ever changes, show their full path
        ivy-virtual-abbreviate 'full
        ;; don't quit minibuffer on delete-error
        ivy-on-del-error-function nil
        ;; enable ability to select prompt (alternative to `ivy-immediate-done')
        ivy-use-selectable-prompt t)

  ;; Ensure a jump point is registered before jumping to new locations with ivy
    (defvar +ivy--origin nil)

    (defun +ivy|record-position-maybe ()
        (with-ivy-window
        (setq +ivy--origin (point-marker))))
    (setq ivy-hooks-alist '((t . +ivy|record-position-maybe)))

    (defun +ivy|set-jump-point-maybe ()
        (when (and (markerp +ivy--origin)
                (not (equal (with-ivy-window (point-marker)) +ivy--origin)))
        (with-current-buffer (marker-buffer +ivy--origin)
            (better-jumper-set-jump +ivy--origin)))
        (setq +ivy--origin nil))
    (add-hook 'minibuffer-exit-hook #'+ivy|set-jump-point-maybe)

    (with-eval-after-load 'yasnippet
        (add-to-list 'yas-prompt-functions #'+ivy-yas-prompt nil #'eq))

    (defun +ivy*inhibit-ivy-in-evil-ex (orig-fn &rest args)
        "`ivy-completion-in-region' struggles with completing certain
    evil-ex-specific constructs, so we disable it solely in evil-ex."
        (let ((completion-in-region-function #'completion--in-region))
        (apply orig-fn args)))
    (advice-add #'evil-ex :around #'+ivy*inhibit-ivy-in-evil-ex)

    (define-key! ivy-mode-map
        [remap switch-to-buffer]              #'+ivy/switch-buffer
        [remap switch-to-buffer-other-window] #'+ivy/switch-buffer-other-window
        [remap persp-switch-to-buffer]        #'+ivy/switch-workspace-buffer)

    (define-key ivy-minibuffer-map (kbd "C-c C-e") #'+ivy/woccur)

    (ivy-mode +1)

    (use-package ivy-hydra
        :commands (ivy-dispatching-done-hydra ivy--matcher-desc ivy-hydra/body)
        :init
        (define-key! ivy-minibuffer-map
        "C-o" #'ivy-dispatching-done-hydra
        "M-o" #'hydra-ivy/body)
        :config
        ;; ivy-hydra rebinds this, so we have to do so again
        (define-key ivy-minibuffer-map (kbd "M-o") #'hydra-ivy/body)))

    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package amx
    :config
    (setq amx-save-file (concat my/cache-dir "amx-items")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package counsel
  :commands counsel-describe-face
  :init
  (map! [remap apropos]                  #'counsel-apropos
        [remap bookmark-jump]            #'counsel-bookmark
        [remap describe-face]            #'counsel-faces
        [remap describe-function]        #'counsel-describe-function
        [remap describe-variable]        #'counsel-describe-variable
        [remap describe-bindings]        #'counsel-descbinds
        [remap set-variable]             #'counsel-set-variable
        [remap execute-extended-command] #'counsel-M-x
        [remap find-file]                #'counsel-find-file
        [remap find-library]             #'counsel-find-library
        [remap info-lookup-symbol]       #'counsel-info-lookup-symbol
        [remap imenu]                    #'counsel-imenu
        [remap recentf-open-files]       #'counsel-recentf
        [remap org-capture]              #'counsel-org-capture
        [remap swiper]                   #'counsel-grep-or-swiper
        [remap evil-ex-registers]        #'counsel-evil-registers
        [remap yank-pop]                 #'counsel-yank-pop)
  :config
;;   (set-popup-rule! "^\\*ivy-occur" :size 0.35 :ttl 0 :quit nil)

  (setq counsel-find-file-ignore-regexp "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)"
        counsel-describe-function-function #'helpful-callable
        counsel-describe-variable-function #'helpful-variable
        ;; Add smart-casing (-S) to default command arguments:
        counsel-rg-base-command "rg -S --no-heading --line-number --color never %s ."
        counsel-ag-base-command "ag -S --nocolor --nogroup %s"
        counsel-pt-base-command "pt -S --nocolor --nogroup -e %s")

  (add-to-list 'swiper-font-lock-exclude #'+doom-dashboard-mode nil #'eq)

  ;; Record in jumplist when opening files via counsel-{ag,rg,pt,git-grep}
  (add-hook 'counsel-grep-post-action-hook #'better-jumper-set-jump)

  ;; Factories
  (defun +ivy-action-reloading (cmd)
    (lambda (x)
      (funcall cmd x)
      (ivy--reset-state ivy-last)))

  (defun +ivy-action-given-file (cmd prompt)
    (lambda (source)
      (let* ((enable-recursive-minibuffers t)
             (target (read-file-name (format "%s %s to:" prompt source))))
        (funcall cmd source target 1))))

  ;; Configure `counsel-find-file'
  (ivy-add-actions
   'counsel-find-file
   `(("b" counsel-find-file-cd-bookmark-action "cd bookmark")
     ("s" counsel-find-file-as-root "open as root")
     ("m" counsel-find-file-mkdir-action "mkdir")
     ("c" ,(+ivy-action-given-file #'copy-file "Copy file") "copy file")
     ("d" ,(+ivy-action-reloading #'+ivy-confirm-delete-file) "delete")
     ("r" (lambda (path) (rename-file path (read-string "New name: "))) "rename")
     ("R" ,(+ivy-action-reloading (+ivy-action-given-file #'rename-file "Move")) "move")
     ("f" find-file-other-window "other window")
     ("F" find-file-other-frame "other frame")
     ("p" (lambda (path) (with-ivy-window (insert (file-relative-name path default-directory)))) "insert relative path")
     ("P" (lambda (path) (with-ivy-window (insert path))) "insert absolute path")
     ("l" (lambda (path) "Insert org-link with relative path"
            (with-ivy-window (insert (format "[[./%s]]" (file-relative-name path default-directory))))) "insert org-link (rel. path)")
     ("L" (lambda (path) "Insert org-link with absolute path"
            (with-ivy-window (insert (format "[[%s]]" path)))) "insert org-link (abs. path)")))

  (ivy-add-actions
   'counsel-ag ; also applies to `counsel-rg' & `counsel-pt'
   '(("O" +ivy-git-grep-other-window-action "open in other window"))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :defer t
  :init
  (map! [remap projectile-find-file]        #'+ivy/projectile-find-file
        [remap projectile-find-dir]         #'counsel-projectile-find-dir
        [remap projectile-switch-to-buffer] #'counsel-projectile-switch-to-buffer
        [remap projectile-grep]             #'counsel-projectile-grep
        [remap projectile-ag]               #'counsel-projectile-ag
        [remap projectile-switch-project]   #'counsel-projectile-switch-project)
  :config
  ;; no highlighting visited files; slows down the filtering
  (ivy-set-display-transformer #'counsel-projectile-find-file nil))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package swiper)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package ivy-hydra)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package ivy-prescient
  :hook (ivy-mode . ivy-prescient-mode)
  :init
  (setq prescient-filter-method '(literal regexp initialism)
        ;; (if (featurep! +fuzzy)
        ;;     '(literal regexp initialism fuzzy)
        ;;   '(literal regexp initialism))
        ivy-prescient-enable-filtering t  ; we do this ourselves
        ivy-prescient-retain-classic-highlighting t
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist
        '((counsel-ag . +ivy-prescient-non-fuzzy)
          (counsel-rg . +ivy-prescient-non-fuzzy)
          (counsel-grep . +ivy-prescient-non-fuzzy)
          (swiper . +ivy-prescient-non-fuzzy)
          (swiper-isearch . +ivy-prescient-non-fuzzy)
          (t . ivy-prescient-re-builder)))

  :config
  (defun +ivy-prescient-non-fuzzy (str)
    (let ((prescient-filter-method '(literal regexp)))
      (ivy-prescient-re-builder str)))

  ;; NOTE prescient config duplicated with `company'
  (setq prescient-save-file (concat my/cache-dir "prescient-save.el"))
  (prescient-persist-mode +1))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package ivy-rich
    :after ivy
    :config
    (cl-pushnew '(+ivy-rich-buffer-icon)
        (cadr (plist-get ivy-rich-display-transformers-list
                'ivy-switch-buffer)))

  ;; Include variable value in `counsel-describe-variable'
    (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                    'counsel-describe-variable
                    '(:columns
                        ((counsel-describe-variable-transformer (:width 40)) ; the original transformer
                        (+ivy-rich-describe-variable-transformer (:width 50))
                        (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))))

    ;; Remove built-in coloring of buffer list; we do our own
    (setq ivy-switch-buffer-faces-alist nil)
    (ivy-set-display-transformer 'internal-complete-buffer nil)

    ;; Highlight buffers differently based on whether they're in the same project
    ;; as the current project or not.
    (let* ((plist (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer))
            (switch-buffer-alist (assq 'ivy-rich-candidate (plist-get plist :columns))))
    (when switch-buffer-alist
        (setcar switch-buffer-alist '+ivy-rich-buffer-name)))

    ;; Apply switch buffer transformers to `counsel-projectile-switch-to-buffer' as well
    (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                    'counsel-projectile-switch-to-buffer
                    (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer)))

    ;; Reload ivy which so changes to `ivy-rich-display-transformers-list' work
    (ivy-rich-mode +1))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package wgrep
  :commands wgrep-change-to-wgrep-mode
  :config (setq wgrep-auto-save-buffer t))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :after ivy
  :config
  ;; `all-the-icons-ivy' is incompatible with ivy-rich's switch-buffer
  ;; modifications, so we disable them and merge them ourselves
  (setq all-the-icons-ivy-buffer-commands nil)

  (all-the-icons-ivy-setup)
  (with-eval-after-load 'counsel-projectile
    (let ((all-the-icons-ivy-file-commands '(counsel-projectile
                                             counsel-projectile-find-file
                                             counsel-projectile-find-dir)))
      (all-the-icons-ivy-setup))))
    #+END_SRC

** Help

   #+BEGIN_SRC emacs-lisp
(use-package help-mode
  :straight (help-mode :type built-in)
  :bind
  (:map help-mode-map
        ("<" . help-go-back)
        (">" . help-go-forward)))
   #+END_SRC

** Hydra

   Hydra allows me to group binds together. It also shows a list of all implemented
   commands in the echo area.

   #+BEGIN_QUOTE
   Once you summon the Hydra through the prefixed binding (the body + any one
   head), all heads can be called in succession with only a short extension.

   The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
   arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
   original purpose, calling his proper command. This makes the Hydra very
   seamless, it's like a minor mode that disables itself auto-magically.

   [[https://github.com/abo-abo/hydra][Oleh Krehel]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :bind
  ("C-c <tab>" . hydra-fold/body)
  ("C-c d" . hydra-dates/body)
  ("C-c e" . hydra-eyebrowse/body)
  ("C-c f" . hydra-flycheck/body)
  ("C-c g" . hydra-magit/body)
  ("C-c h" . hydra-helm/body)
  ("C-c o" . me/ongoing-hydra)
  ("C-c p" . hydra-projectile/body)
  ("C-c s" . hydra-system/body)
  ("C-c w" . hydra-windows/body)
  :custom
  (hydra-default-hint nil))
   #+END_SRC

*** Hydra / Dates

    Group date-related commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color blue)
  "
^
^Dates^             ^Insert^            ^Insert with Time^
^─────^─────────────^──────^────────────^────────────────^──
_q_ quit            _d_ short           _D_ short
^^                  _i_ iso             _I_ iso
^^                  _l_ long            _L_ long
^^                  ^^                  ^^
"
  ("q" nil)
  ("d" me/date-short)
  ("D" me/date-short-with-time)
  ("i" me/date-iso)
  ("I" me/date-iso-with-time)
  ("l" me/date-long)
  ("L" me/date-long-with-time))
    #+END_SRC

    [[./screenshots/hydra.dates.png]]

*** Hydra / Eyebrowse

    Group Eyebrowse commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-eyebrowse (:color blue)
  "
^
^Eyebrowse^         ^Do^                ^Switch^
^─────────^─────────^──^────────────────^──────^────────────
_q_ quit            _c_ create          _<_ previous
^^                  _k_ kill            _>_ next
^^                  _r_ rename          _e_ last
^^                  ^^                  _s_ switch
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" eyebrowse-prev-window-config :color red)
  (">" eyebrowse-next-window-config :color red)
  ("c" eyebrowse-create-window-config)
  ("e" eyebrowse-last-window-config)
  ("k" eyebrowse-close-window-config :color red)
  ("r" eyebrowse-rename-window-config)
  ("s" eyebrowse-switch-to-window-config))
    #+END_SRC

    [[./screenshots/hydra.eyebrowse.png]]

*** Hydra / Flycheck

    Group Flycheck commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck (:color pink)
  "
^
^Flycheck^          ^Errors^            ^Checker^
^────────^──────────^──────^────────────^───────^───────────
_q_ quit            _<_ previous        _?_ describe
_m_ manual          _>_ next            _d_ disable
_v_ verify setup    _f_ check           _s_ select
^^                  _l_ list            ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" flycheck-previous-error)
  (">" flycheck-next-error)
  ("?" flycheck-describe-checker :color blue)
  ("d" flycheck-disable-checker :color blue)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors :color blue)
  ("m" flycheck-manual :color blue)
  ("s" flycheck-select-checker :color blue)
  ("v" flycheck-verify-setup :color blue))
    #+END_SRC

    [[./screenshots/hydra.flycheck.png]]

*** Hydra / Helm

    Group Helm commands.

    - *TODO*: Make =helm-mdi=.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:color blue)
  "
^
^Helm^              ^Browse^
^────^──────────────^──────^────────────
_q_ quit            _c_ colors
_r_ resume          _g_ google
^^                  _i_ imenu
^^                  _k_ kill-ring
^^                  ^^
"
  ("q" nil)
  ("c" helm-colors)
  ("g" helm-google-suggest)
  ("i" helm-imenu)
  ("k" helm-show-kill-ring)
  ("r" helm-resume))
    #+END_SRC

    [[./screenshots/hydra.helm.png]]

*** Hydra / Magit

    Group Magit commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-magit (:color blue)
  "
^
^Magit^             ^Do^
^─────^─────────────^──^────────────────
_q_ quit            _b_ blame
^^                  _c_ clone
^^                  _i_ init
^^                  _s_ status
^^                  ^^
"
  ("q" nil)
  ("b" magit-blame)
  ("c" magit-clone)
  ("i" magit-init)
  ("s" magit-status))
    #+END_SRC

    [[./screenshots/hydra.magit.png]]

*** Hydra / Markdown

    Group Markdown commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-markdown (:color pink)
  "
^
^Markdown^          ^Table Columns^     ^Table Rows^
^────────^──────────^─────────────^─────^──────────^────────
_q_ quit            _c_ insert          _r_ insert
^^                  _C_ delete          _R_ delete
^^                  _M-<left>_ left     _M-<down>_ down
^^                  _M-<right>_ right   _M-<up>_ up
^^                  ^^                  ^^
"
  ("q" nil)
  ("c" markdown-table-insert-column)
  ("C" markdown-table-delete-column)
  ("r" markdown-table-insert-row)
  ("R" markdown-table-delete-row)
  ("M-<left>" markdown-table-move-column-left)
  ("M-<right>" markdown-table-move-column-right)
  ("M-<down>" markdown-table-move-row-down)
  ("M-<up>" markdown-table-move-row-up))
    #+END_SRC

    [[./screenshots/hydra.markdown.png]]

*** Hydra / Org

    Group Org commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color pink)
  "
^
^Org^               ^Links^             ^Outline^
^───^───────────────^─────^─────────────^───────^───────────
_q_ quit            _i_ insert          _<_ previous
^^                  _n_ next            _>_ next
^^                  _p_ previous        _a_ all
^^                  _s_ store           _o_ goto
^^                  ^^                  _v_ overview
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" org-backward-element)
  (">" org-forward-element)
  ("a" outline-show-all)
  ("i" org-insert-link :color blue)
  ("n" org-next-link)
  ("o" helm-org-in-buffer-headings :color blue)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
    #+END_SRC

    [[./screenshots/hydra.org.png]]

*** Hydra / Projectile

    Group Projectile commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-projectile (:color blue)
  "
^
^Projectile^        ^Buffers^           ^Find^              ^Search^
^──────────^────────^───────^───────────^────^──────────────^──────^────────────
_q_ quit            _b_ list            _d_ directory       _r_ replace
_i_ reset cache     _K_ kill all        _D_ root            _R_ regexp replace
^^                  _S_ save all        _f_ file            _s_ ag
^^                  ^^                  _p_ project         ^^
^^                  ^^                  ^^                  ^^
"
  ("q" nil)
  ("b" helm-projectile-switch-to-buffer)
  ("d" helm-projectile-find-dir)
  ("D" projectile-dired)
  ("f" helm-projectile-find-file)
  ("i" projectile-invalidate-cache :color red)
  ("K" projectile-kill-buffers)
  ("p" helm-projectile-switch-project)
  ("r" projectile-replace)
  ("R" projectile-replace-regexp)
  ("s" helm-projectile-ag)
  ("S" projectile-save-project-buffers))
    #+END_SRC

    [[./screenshots/hydra.projectile.png]]

*** Hydra / RJSX

    Group React JavaScript commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-rjsx (:color pink)
  "
^
^RJSX^
^────^──────────────
_q_ quit
^^
"
  ("q" nil))
    #+END_SRC

    [[./screenshots/hydra.rjsx.png]]

*** Hydra / System

    Group system-related commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-system (:color blue)
  "
^
^System^            ^Packages^          ^Processes^         ^Shell^
^──────^────────────^────────^──────────^─────────^─────────^─────^─────────────
_q_ quit            _p_ list            _s_ list            _e_ eshell
^^                  _P_ upgrade         ^^                  _t_ term
^^                  ^^                  ^^                  _T_ ansi-term
"
  ("q" nil)
  ("e" (eshell t))
  ("p" paradox-list-packages)
  ("P" paradox-upgrade-packages)
  ("s" list-processes)
  ("t" term)
  ("T" ansi-term))
    #+END_SRC

    [[./screenshots/hydra.system.png]]

*** Hydra / Windows

    Group window-related commands.

    #+BEGIN_SRC emacs-lisp
(defhydra hydra-windows (:color pink)
  "
^
^Windows^           ^Window^            ^Zoom^
^───────^───────────^──────^────────────^────^──────────────
_q_ quit            _b_ balance         _-_ out
^^                  _i_ heighten        _+_ in
^^                  _j_ narrow          _=_ reset
^^                  _k_ lower           ^^
^^                  _l_ widen           ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("b" balance-windows)
  ("i" enlarge-window)
  ("j" shrink-window-horizontally)
  ("k" shrink-window)
  ("l" enlarge-window-horizontally)
  ("-" text-scale-decrease)
  ("+" text-scale-increase)
  ("=" (text-scale-increase 0)))
    #+END_SRC

    [[./screenshots/hydra.windows.png]]

** IRC

   - *TODO*: Display the current count of users. =(hash-table-count erc-channel-users)=

   #+BEGIN_SRC emacs-lisp
(use-package erc
  :preface
  (defun me/erc ()
    "Connect to `me/erc-server' on `me/erc-port' as `me/erc-nick' with
    `me/erc-password'."
    (interactive)
    (erc :server me/erc-server
         :port me/erc-port
         :nick me/erc-nick
         :password me/erc-password))
  (defun me/erc-bol-shifted ()
    "See `erc-bol'. Support shift."
    (interactive "^")
    (erc-bol))
  (defun me/erc-set-fill-column ()
    "Set `erc-fill-column' to the width of the current window."
    (save-excursion
      (walk-windows
       (lambda (window)
         (let ((buffer (window-buffer window)))
           (set-buffer buffer)
           (when (and (eq major-mode 'erc-mode) (erc-buffer-visible buffer))
             (setq erc-fill-column (- (window-width window) 2))))))))
;;   :bind
;;   (:map erc-mode-map
;;         ([remap erc-bol] . me/erc-bol-shifted)
;;         ("M-<down>" . erc-next-command)
;;         ("M-<up>" . erc-previous-command))
  :hook
  (erc-mode . (lambda () (setq-local scroll-margin 0)))
  (window-configuration-change . me/erc-set-fill-column)
  :custom
  (erc-autojoin-channels-alist '(("freenode.net" "#emacs")))
  (erc-fill-function 'erc-fill-static)
  (erc-fill-static-center 19)
  (erc-header-line-format nil)
  (erc-insert-timestamp-function 'erc-insert-timestamp-left)
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
  (erc-prompt (format "%18s" ">"))
  (erc-timestamp-format nil)
  :config
  (make-variable-buffer-local 'erc-fill-column)
  (erc-scrolltobottom-enable))
   #+END_SRC

** Linters

   Flycheck lints warnings and errors directly within buffers. It can check a lot
   of different syntaxes, as long as you make sure that Emacs has access to the
   binaries (see [[./README.org][README.org]]).

   #+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook
  ((css-mode . flycheck-mode)
   (emacs-lisp-mode . flycheck-mode)
   (js-mode . flycheck-mode)
   (python-mode . flycheck-mode))
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay .3))
   #+END_SRC

** Navigation

*** Navigation / Inline

    Smarter =C-a=.

    #+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line] #'me/beginning-of-line-dwim)

(defun me/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
    #+END_SRC

*** Navigation / Paragraphs

    I disagree with Emacs' definition of paragraphs so I redefined the way it should
    jump from one paragraph to another.

    - *TOFIX*: Ignore invisible text.

    #+BEGIN_SRC emacs-lisp
;; (global-set-key [remap backward-paragraph] #'me/backward-paragraph-dwim)
;; (global-set-key [remap forward-paragraph] #'me/forward-paragraph-dwim)

(defun me/backward-paragraph-dwim ()
  "Move backward to start of paragraph."
  (interactive "^")
  (skip-chars-backward "\n")
  (unless (search-backward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-min)))
  (skip-chars-forward "\n"))

(defun me/forward-paragraph-dwim ()
  "Move forward to start of next paragraph."
  (interactive "^")
  (skip-chars-forward "\n")
  (unless (search-forward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-max)))
  (skip-chars-forward "\n"))
    #+END_SRC

*** Navigation / Pulse

    Pulse temporarily highlights the background color of a line or region.

    #+BEGIN_SRC emacs-lisp
(use-package pulse :ensure nil)
    #+END_SRC

*** Navigation / Replace

    Better search and replace features. Even though I prefer to use
    =multiple-cursors= to replace text in different places at once, =anzu= has a
    nice feedback on regexp matches.

    #+BEGIN_QUOTE
    =anzu.el= is an Emacs port of
    [[https://github.com/osyo-manga/vim-anzu][anzu.vim]]. =anzu.el= provides a minor
    mode which displays /current match/ and /total matches/ information in the
    mode-line in various search modes.

    [[https://github.com/syohex/emacs-anzu][Syohei Yoshida]]
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
(use-package anzu
    :bind
    ([remap query-replace] . anzu-query-replace-regexp)
    :hook
    (after-init . global-anzu-mode)
    :custom
    (anzu-cons-mode-line-p nil))
    #+END_SRC

**** Evil
     #+BEGIN_SRC emacs-lisp
(use-package evil-anzu)
     #+END_SRC


*** Navigation / Scroll

    Enable horizontal scroll.

    - *TODO*: Scroll the window under cursor instead of where point is.

    #+BEGIN_SRC emacs-lisp
(put 'scroll-left 'disabled nil)
(defun me/scroll-left ()
  (interactive)
  (when truncate-lines (scroll-left 2)))
(defun me/scroll-right ()
  (interactive)
  (when truncate-lines (scroll-right 2)))
(global-set-key (kbd "<wheel-left>") #'me/scroll-right)
(global-set-key (kbd "<wheel-right>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-down>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-up>") #'me/scroll-right)
    #+END_SRC

    Configure the mouse scroll.

    #+BEGIN_SRC emacs-lisp
(use-package mwheel
  :straight (mwheel :type built-in)
  :custom
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(1 ((control) . 5))))
    #+END_SRC

*** Navigation / Search

    Isearch stands for /incremental search/. This means that search results are
    highlighted while you are typing your query, incrementally. Since he who can do
    more can do less, I've replaced default bindings with the regexp-equivalent
    commands.

    #+BEGIN_SRC emacs-lisp
(use-package isearch
    :straight (mwheel :type built-in)
    :defer t
    :bind
    (("C-S-r" . isearch-backward-regexp)
    ("C-S-s" . isearch-forward-regexp)
    :map isearch-mode-map
    ("<M-down>" . isearch-ring-advance)
    ("<M-up>" . isearch-ring-retreat)
    :map minibuffer-local-isearch-map
    ("<M-down>" . next-history-element)
    ("<M-up>" . previous-history-element))
    :init
    (setq-default
        isearch-allow-scroll t
        lazy-highlight-cleanup nil
        lazy-highlight-initial-delay 0))
    #+END_SRC

** Parentheses

   Highlight parenthese-like delimiters in a rainbow fashion. It ease the reading
   when dealing with mismatched parentheses.

   #+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
   #+END_SRC

   I am still looking for the perfect parenthesis management setup as of
   today... No package seem to please my person.

   #+BEGIN_SRC emacs-lisp
   (use-package smartparens
     :custom
     (sp-show-pair-delay 0.25)
     ;; (sp-highlight-pair-overlay nil)
     ;; (sp-highlight-wrap-overlay nil)
     ;; (sp-highlight-wrap-tag-overlay nil)
     :config
     (show-paren-mode 0)
     (require 'smartparens-config)
     (show-smartparens-global-mode t)
     (smartparens-global-mode +1))
   #+END_SRC

** Paste

   #+BEGIN_QUOTE
   This mode allows to paste whole buffers or parts of buffers to pastebin-like
   services. It supports more than one service and will failover if one service
   fails.

   [[https://github.com/etu/webpaste.el][Elis Hirwing]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package webpaste
    :defer t
    :config
    (setq webpaste-provider-priority '("gist.github.com" "ix.io" "dpaste.de"))
    (setq webpaste-paste-confirmation t))
   #+END_SRC

** Projectile

   Projectile brings project-level facilities to Emacs such as grep, find and
   replace.

   #+BEGIN_QUOTE
   Projectile is a project interaction library for Emacs. Its goal is to provide a
   nice set of features operating on a project level without introducing external
   dependencies (when feasible). For instance - finding project files has a
   portable implementation written in pure Emacs Lisp without the use of GNU find
   (but for performance sake an indexing mechanism backed by external commands
   exists as well).

   [[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook
  (after-init . projectile-global-mode)
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" my/cache-dir)
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory))
  :custom
  (projectile-completion-system 'ivy)
  (projectile-enable-caching t))
   #+END_SRC

** Quality of Life

   Auto-indent code as you write.

   #+BEGIN_QUOTE
   =electric-indent-mode= is enough to keep your code nicely aligned when all you
   do is type. However, once you start shifting blocks around, transposing lines,
   or slurping and barfing sexps, indentation is bound to go wrong.

   =aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
   It reindents after every change, making it more reliable than
   electric-indent-mode.

   [[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
   #+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((css-mode . aggressive-indent-mode)
   (emacs-lisp-mode . aggressive-indent-mode)
   (js-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (sgml-mode . aggressive-indent-mode))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

   Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun me/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun me/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun me/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun me/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun me/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun me/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

   Disable documentation for object at point in the echo area. It conflicts with Flycheck.

   #+BEGIN_SRC emacs-lisp
(use-package eldoc
  :straight (eldoc :type built-in)
  :config (global-eldoc-mode -1))
   #+END_SRC

   Add visual guides towards indenting levels.

   #+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook
  (python-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character)
  :config
  (progn
        (defvar custom-buffer-hl-indent-mode nil)

        (defun me/disable-hl-indent ()
            (when highlight-indent-guides-mode
                (setq-local custom-buffer-hl-indent-mode t)
                (highlight-indent-guides-mode -1)))
        (add-hook 'evil-visual-state-entry-hook #'me/disable-hl-indent)

        (defun me/enable-hl-indent-maybe ()
            (when custom-buffer-hl-indent-mode
                (highlight-indent-guides-mode +1)))

        (add-hook 'evil-visual-state-exit-hook  #'me/enable-hl-indent-maybe)))
   #+END_SRC

   Highlight line under point.

   #+BEGIN_SRC emacs-lisp
(use-package hl-line
    :preface (defun me/hl-line-mode-off () (setq-local global-hl-line-mode nil))
    :hook (after-init . global-hl-line-mode)
    :config
    (progn
        (defvar custom-buffer-hl-line-mode nil)

        (defun me/disable-hl-line ()
            (when hl-line-mode
                (setq-local custom-buffer-hl-line-mode t)
                (hl-line-mode -1)))
        (add-hook 'evil-visual-state-entry-hook #'me/disable-hl-line)

        (defun me/enable-hl-line-maybe ()
            (when custom-buffer-hl-line-mode
                (hl-line-mode +1)))

        (add-hook 'evil-visual-state-exit-hook  #'me/enable-hl-line-maybe)))


   #+END_SRC

   Prettify symbols. Below is the configuration of the prettify-symbol feature. You
   should enable the feature as a minor-mode and on a per-mode basis only.

   #+BEGIN_SRC emacs-lisp
(use-package prog-mode
  :straight (prog-mode :type built-in)
  :preface
  (defun me/prettify-symbols-compose-predicate (&rest arguments)
    (when (not (eq system-type 'windows-nt))
      (apply #'prettify-symbols-default-compose-p arguments)))
  :custom
  (prettify-symbols-compose-predicate #'me/prettify-symbols-compose-predicate)
  (prettify-symbols-unprettify-at-point 'right-edge))
   #+END_SRC

   Colorize colors as text with their value.

   #+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook prog-mode
  :custom (rainbow-x-colors-major-mode-list '()))
   #+END_SRC

   Turn on =auto-fill-mode= /almost/ everywhere.

   #+BEGIN_SRC emacs-lisp
(use-package simple
  :straight (simple :type built-in)
  :hook
  ((prog-mode . turn-on-auto-fill)
   (text-mode . turn-on-auto-fill)))
   #+END_SRC

** Shell and Terminal

   #+BEGIN_SRC emacs-lisp
(use-package em-hist
  :straight (em-hist :type built-in)
  :custom (eshell-hist-ignoredups t))

(use-package esh-mode
  :straight (esh-mode :type built-in)
  :preface
  (defun me/eshell-bol-shifted ()
    "See `eshell-bol'. Support shift."
    (interactive "^")
    (eshell-bol))
  :bind
  (:map eshell-mode-map
        ([remap eshell-bol] . me/eshell-bol-shifted))
  :hook
  ((eshell-mode . me/hl-line-mode-off)
   (eshell-mode . (lambda () (setq-local scroll-margin 0))))
  :custom
  (eshell-scroll-to-bottom-on-input t))
   #+END_SRC

   Yes, Emacs emulates terminals too.

   #+BEGIN_SRC emacs-lisp
(use-package term
  :straight (term :type built-in)
  :hook
  ((term-mode . me/hl-line-mode-off)
   (term-mode . (lambda () (setq-local scroll-margin 0)))))
   #+END_SRC

   Provide a way to invoke =bash= on Windows. This requires "Developer Mode" to
   be enabled in the first place.

   #+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (defun me/bash ()
    (interactive)
    (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
      (shell))))
   #+END_SRC

** Version Control

   Magit provides Git facilities directly from within Emacs.

   #+BEGIN_QUOTE
   Magit is an interface to the version control system
   [[https://git-scm.com/][Git]], implemented as an
   [[https://www.gnu.org/software/emacs][Emacs]] package. Magit aspires to be a
   complete Git porcelain. While we cannot (yet) claim that Magit wraps and
   improves upon each and every Git command, it is complete enough to allow even
   experienced Git users to perform almost all of their daily version control tasks
   directly from within Emacs. While many fine Git clients exist, only Magit and
   Git itself deserve to be called porcelains.
   [[https://magit.vc/about.html][(more)]]

   [[https://github.com/magit/magit][Jonas Bernoulli]]
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
(use-package git-commit
  :preface
  (defun me/git-commit-auto-fill-everywhere ()
    (setq fill-column 72)
    (setq-local comment-auto-fill-only-comments nil))
  :hook
  (git-commit-mode . me/git-commit-auto-fill-everywhere)
  :custom
  (git-commit-summary-max-length 50))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  (:map magit-hunk-section-map
        ("RET" . magit-diff-visit-file-other-window)
        ([return] . magit-diff-visit-file-other-window))
  :custom
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-body nil)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside magit-diff-highlight-hunk-region-using-face))
  (magit-popup-display-buffer-action '((display-buffer-same-window)))
  (magit-refs-show-commit-count 'all)
  (magit-section-show-child-count t)
  :config
  (remove-hook 'magit-section-highlight-hook #'magit-section-highlight))
   #+END_SRC

*** Evil

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
    :after magit
    :init
    (setq evil-magit-state 'normal
        evil-magit-use-z-for-folds t)
    :config
    (unmap! magit-mode-map "M-1" "M-2" "M-3" "M-4") ; replaced by z1, z2, z3, etc
    (evil-define-key* 'normal magit-status-mode-map [escape] nil) ; q is enough
    (evil-define-key* '(normal visual) magit-mode-map
        "zz" #'evil-scroll-line-to-center
        "%"  #'magit-gitflow-popup)
    (define-key! 'normal
        (magit-status-mode-map
        magit-stash-mode-map
        magit-revision-mode-map
        magit-diff-mode-map)
        [tab] #'magit-section-toggle)
    (with-eval-after-load 'git-rebase
        (dolist (key '(("M-k" . "gk") ("M-j" . "gj")))
        (when-let (desc (assoc (car key) evil-magit-rebase-commands-w-descriptions))
            (setcar desc (cdr key))))
        (evil-define-key* evil-magit-state git-rebase-mode-map
        "gj" #'git-rebase-move-line-down
        "gk" #'git-rebase-move-line-up)))
#+END_SRC

*** Git flow                                                            :tes:

#+BEGIN_SRC emacs-lisp
(use-package magit-gitflow
    :hook (magit-mode . turn-on-magit-gitflow))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+END_SRC

** Whitespaces

   Highlight space-like characters, eg. trailing spaces, tabs, empty lines.


   #+BEGIN_SRC emacs-lisp
(use-package whitespace
  :straight (whitespace :type built-in)
  :hook
  ((prog-mode . whitespace-turn-on)
   (text-mode . whitespace-turn-on))
  :custom
  (whitespace-style '(face empty indentation::space tab trailing)))
   #+END_SRC


   Delete on save

   #+BEGIN_SRC emacs-lisp
(use-package ws-butler
    :config
    (setq ws-butler-global-exempt-modes
            (append ws-butler-global-exempt-modes
                    '(special-mode comint-mode term-mode eshell-mode)))
    (ws-butler-global-mode))
   #+END_SRC



* Symbols

** Symbols

   #+BEGIN_SRC emacs-lisp
(defvar +pretty-code-symbols
  '(;; org
    :name          "»"
    :src_block     "»"
    :src_block_end "«"
    ;; Functional
    :lambda        "λ"
    :def           "ƒ"
    :composition   "∘"
    :map           "↦"
    ;; Types
    :null          "∅"
    :true          "𝕋"
    :false         "𝔽"
    :int           "ℤ"
    :float         "ℝ"
    :str           "𝕊"
    :bool          "𝔹"
    ;; Flow
    :not           "￢"
    :in            "∈"
    :not-in        "∉"
    :and           "∧"
    :or            "∨"
    :for           "∀"
    :some          "∃"
    :return        "⟼"
    :yield         "⟻"
    ;; Other
    :tuple         "⨂"
    :pipe          "" ;; FIXME: find a non-private char
    :dot           "•")
  "Options plist for `set-pretty-symbols!'.

This should not contain any symbols from the Unicode Private Area! There is no
universal way of getting the correct symbol as that area varies from font to
font.")


(defvar +pretty-code-symbols-alist '((t))
  "An alist containing a mapping of major modes to its value for
`prettify-symbols-alist'.")

(defun +pretty-code--correct-symbol-bounds (ligature-alist)
  "Prepend non-breaking spaces to a ligature.

This way `compose-region' (called by `prettify-symbols-mode') will use the
correct width of the symbols instead of the width measured by `char-width'."
  (let ((len (length (car ligature-alist)))
        (acc (list   (cdr ligature-alist))))
    (while (> len 1)
      (setq acc (cons #X00a0 (cons '(Br . Bl) acc))
            len (1- len)))
    (cons (car ligature-alist) acc)))
(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))

(defun set-pretty-symbols! (modes &rest plist)
  "Associates string patterns with icons in certain major-modes.

  MODES is a major mode symbol or a list of them.
  PLIST is a property list whose keys must match keys in `+pretty-code-symbols',
and whose values are strings representing the text to be replaced with that
symbol. If the car of PLIST is nil, then unset any pretty symbols previously
defined for MODES.

The following properties are special:

  :alist ALIST
    Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
    `+pretty-code-symbols'.
  :merge BOOL
    If non-nil, merge with previously defined `prettify-symbols-alist',
    otherwise overwrite it.

For example, the rule for emacs-lisp-mode is very simple:

  (set-pretty-symbols! 'emacs-lisp-mode
    :lambda \"lambda\")

This will replace any instances of \"lambda\" in emacs-lisp-mode with the symbol
assicated with :lambda in `+pretty-code-symbols'.

Pretty symbols can be unset for emacs-lisp-mode with:

  (set-pretty-symbols! 'emacs-lisp-mode nil)"
  (declare (indent defun))
  (if (null (car-safe plist))
      (dolist (mode (doom-enlist modes))
        (delq (assq mode +pretty-code-symbols-alist)
              +pretty-code-symbols-alist))
    (let (results merge key)
      (while plist
        (pcase (setq key (pop plist))
          (:merge (setq merge (pop plist)))
          (:alist (setq results (append (pop plist) results)))
          (_
           (when-let (char (plist-get +pretty-code-symbols key))
             (push (cons (pop plist) char) results)))))
      (dolist (mode (doom-enlist modes))
        (unless merge
          (delq (assq mode +pretty-code-symbols-alist)
                +pretty-code-symbols-alist))
        (push (cons mode results) +pretty-code-symbols-alist)))))
(global-prettify-symbols-mode 1)

(set-pretty-symbols! 'emacs-lisp-mode
  :return "return"
  :for "for"
  :not "!")

(defvar +pretty-code-enabled-modes t
    "List of major modes in which `prettify-symbols-mode' should be enabled.
If t, enable it everywhere. If the first element is 'not, enable it in any mode
besides what is listed.")

;; When you get to the right edge, it goes back to how it normally prints
(setq prettify-symbols-unprettify-at-point 'right-edge)

(defun +pretty-code|init-pretty-symbols ()
  "Enable `prettify-symbols-mode'.

If in fundamental-mode, or a mode derived from special, comint, eshell or term
modes, this function does nothing.

Otherwise it builds `prettify-code-symbols-alist' according to
`+pretty-code-symbols-alist' for the current major-mode."
  (unless (or (eq major-mode 'fundamental-mode)
              (eq (get major-mode 'mode-class) 'special)
              (derived-mode-p 'comint-mode 'eshell-mode 'term-mode))
    (when (or (eq +pretty-code-enabled-modes t)
              (if (eq (car +pretty-code-enabled-modes) 'not)
                  (not (memq major-mode (cdr +pretty-code-enabled-modes)))
                (memq major-mode +pretty-code-enabled-modes)))
      (setq prettify-symbols-alist
            (append (cdr (assq major-mode +pretty-code-symbols-alist))
                    (default-value 'prettify-symbols-alist)))
      (when prettify-symbols-mode
        (prettify-symbols-mode -1))
      (prettify-symbols-mode +1))))

(add-hook 'after-change-major-mode-hook #'+pretty-code|init-pretty-symbols)
   #+END_SRC
   -----

   [[#dotemacs][Back to top]]
